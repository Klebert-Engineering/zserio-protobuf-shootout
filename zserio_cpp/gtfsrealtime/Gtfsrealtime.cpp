/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/Incrementality.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Incrementality enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::gtfsrealtime::Incrementality>::names;
constexpr ::std::array<::gtfsrealtime::Incrementality, 2> EnumTraits<::gtfsrealtime::Incrementality>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::Incrementality value)
{
    switch (value)
    {
    case ::gtfsrealtime::Incrementality::FULL_DATASET:
        return 0;
    case ::gtfsrealtime::Incrementality::DIFFERENTIAL:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Incrementality: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::Incrementality valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return ::gtfsrealtime::Incrementality(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Incrementality: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::Incrementality>(::gtfsrealtime::Incrementality value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Incrementality value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::Incrementality)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Incrementality value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::Incrementality value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::Incrementality value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::Incrementality read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Incrementality>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::Incrementality read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Incrementality>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::Incrementality value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::Incrementality value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Incrementality>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/StopTimeScheduleRelationship.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for StopTimeScheduleRelationship enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::gtfsrealtime::StopTimeScheduleRelationship>::names;
constexpr ::std::array<::gtfsrealtime::StopTimeScheduleRelationship, 3> EnumTraits<::gtfsrealtime::StopTimeScheduleRelationship>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::StopTimeScheduleRelationship value)
{
    switch (value)
    {
    case ::gtfsrealtime::StopTimeScheduleRelationship::SCHEDULED:
        return 0;
    case ::gtfsrealtime::StopTimeScheduleRelationship::SKIPPED:
        return 1;
    case ::gtfsrealtime::StopTimeScheduleRelationship::NO_DATA:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StopTimeScheduleRelationship: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::StopTimeScheduleRelationship valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return ::gtfsrealtime::StopTimeScheduleRelationship(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration StopTimeScheduleRelationship: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::StopTimeScheduleRelationship>(::gtfsrealtime::StopTimeScheduleRelationship value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::StopTimeScheduleRelationship)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::StopTimeScheduleRelationship read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::StopTimeScheduleRelationship>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::StopTimeScheduleRelationship read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::StopTimeScheduleRelationship>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::StopTimeScheduleRelationship value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::StopTimeScheduleRelationship>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/VehicleStopStatus.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for VehicleStopStatus enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::gtfsrealtime::VehicleStopStatus>::names;
constexpr ::std::array<::gtfsrealtime::VehicleStopStatus, 3> EnumTraits<::gtfsrealtime::VehicleStopStatus>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::VehicleStopStatus value)
{
    switch (value)
    {
    case ::gtfsrealtime::VehicleStopStatus::INCOMING_AT:
        return 0;
    case ::gtfsrealtime::VehicleStopStatus::STOPPED_AT:
        return 1;
    case ::gtfsrealtime::VehicleStopStatus::IN_TRANSIT_TO:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration VehicleStopStatus: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::VehicleStopStatus valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return ::gtfsrealtime::VehicleStopStatus(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration VehicleStopStatus: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::VehicleStopStatus>(::gtfsrealtime::VehicleStopStatus value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::VehicleStopStatus value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::VehicleStopStatus)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::VehicleStopStatus value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::VehicleStopStatus value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::VehicleStopStatus value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::VehicleStopStatus read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::VehicleStopStatus>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::VehicleStopStatus read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::VehicleStopStatus>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::VehicleStopStatus value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::VehicleStopStatus value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::VehicleStopStatus>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/CongestionLevel.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for CongestionLevel enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::gtfsrealtime::CongestionLevel>::names;
constexpr ::std::array<::gtfsrealtime::CongestionLevel, 5> EnumTraits<::gtfsrealtime::CongestionLevel>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::CongestionLevel value)
{
    switch (value)
    {
    case ::gtfsrealtime::CongestionLevel::UNKNOWN_CONGESTION_LEVEL:
        return 0;
    case ::gtfsrealtime::CongestionLevel::RUNNING_SMOOTHLY:
        return 1;
    case ::gtfsrealtime::CongestionLevel::STOP_AND_GO:
        return 2;
    case ::gtfsrealtime::CongestionLevel::CONGESTION:
        return 3;
    case ::gtfsrealtime::CongestionLevel::SEVERE_CONGESTION:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CongestionLevel: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::CongestionLevel valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return ::gtfsrealtime::CongestionLevel(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CongestionLevel: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::CongestionLevel>(::gtfsrealtime::CongestionLevel value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::CongestionLevel value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::CongestionLevel)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::CongestionLevel value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::CongestionLevel value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::CongestionLevel value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::CongestionLevel read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::CongestionLevel>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::CongestionLevel read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::CongestionLevel>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::CongestionLevel value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::CongestionLevel value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::CongestionLevel>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/OccupancyStatus.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for OccupancyStatus enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::gtfsrealtime::OccupancyStatus>::names;
constexpr ::std::array<::gtfsrealtime::OccupancyStatus, 7> EnumTraits<::gtfsrealtime::OccupancyStatus>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::OccupancyStatus value)
{
    switch (value)
    {
    case ::gtfsrealtime::OccupancyStatus::EMPTY:
        return 0;
    case ::gtfsrealtime::OccupancyStatus::MANY_SEATS_AVAILABLE:
        return 1;
    case ::gtfsrealtime::OccupancyStatus::FEW_SEATS_AVAILABLE:
        return 2;
    case ::gtfsrealtime::OccupancyStatus::STANDING_ROOM_ONLY:
        return 3;
    case ::gtfsrealtime::OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY:
        return 4;
    case ::gtfsrealtime::OccupancyStatus::FULL:
        return 5;
    case ::gtfsrealtime::OccupancyStatus::NOT_ACCEPTING_PASSENGERS:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration OccupancyStatus: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::OccupancyStatus valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return ::gtfsrealtime::OccupancyStatus(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration OccupancyStatus: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::OccupancyStatus>(::gtfsrealtime::OccupancyStatus value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::OccupancyStatus value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::OccupancyStatus)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::OccupancyStatus value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::OccupancyStatus value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::OccupancyStatus value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::OccupancyStatus read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::OccupancyStatus>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::OccupancyStatus read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::OccupancyStatus>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::OccupancyStatus value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::OccupancyStatus value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::OccupancyStatus>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/Cause.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Cause enumeration.
constexpr ::std::array<const char*, 12> EnumTraits<::gtfsrealtime::Cause>::names;
constexpr ::std::array<::gtfsrealtime::Cause, 12> EnumTraits<::gtfsrealtime::Cause>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::Cause value)
{
    switch (value)
    {
    case ::gtfsrealtime::Cause::UNKNOWN_CAUSE:
        return 0;
    case ::gtfsrealtime::Cause::OTHER_CAUSE:
        return 1;
    case ::gtfsrealtime::Cause::TECHNICAL_PROBLEM:
        return 2;
    case ::gtfsrealtime::Cause::STRIKE:
        return 3;
    case ::gtfsrealtime::Cause::DEMONSTRATION:
        return 4;
    case ::gtfsrealtime::Cause::ACCIDENT:
        return 5;
    case ::gtfsrealtime::Cause::HOLIDAY:
        return 6;
    case ::gtfsrealtime::Cause::WEATHER:
        return 7;
    case ::gtfsrealtime::Cause::MAINTENANCE:
        return 8;
    case ::gtfsrealtime::Cause::CONSTRUCTION:
        return 9;
    case ::gtfsrealtime::Cause::POLICE_ACTIVITY:
        return 10;
    case ::gtfsrealtime::Cause::MEDICAL_EMERGENCY:
        return 11;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Cause: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::Cause valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::Cause>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
        return ::gtfsrealtime::Cause(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Cause: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::Cause>(::gtfsrealtime::Cause value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Cause value)
{
    contextNode.getContext().init(::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::Cause value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Cause value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::Cause value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::Cause value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::Cause read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Cause>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(
                    in.readVarUInt16()));
}

template <>
::gtfsrealtime::Cause read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Cause>(contextNode.getContext().read(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::Cause value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::Cause value)
{
    contextNode.getContext().write(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Cause>::type>(),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/Effect.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Effect enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::gtfsrealtime::Effect>::names;
constexpr ::std::array<::gtfsrealtime::Effect, 9> EnumTraits<::gtfsrealtime::Effect>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::Effect value)
{
    switch (value)
    {
    case ::gtfsrealtime::Effect::NO_SERVICE:
        return 0;
    case ::gtfsrealtime::Effect::REDUCED_SERVICE:
        return 1;
    case ::gtfsrealtime::Effect::SIGNIFICANT_DELAYS:
        return 2;
    case ::gtfsrealtime::Effect::DETOUR:
        return 3;
    case ::gtfsrealtime::Effect::ADDITIONAL_SERVICE:
        return 4;
    case ::gtfsrealtime::Effect::MODIFIED_SERVICE:
        return 5;
    case ::gtfsrealtime::Effect::OTHER_EFFECT:
        return 6;
    case ::gtfsrealtime::Effect::UNKNOWN_EFFECT:
        return 7;
    case ::gtfsrealtime::Effect::STOP_MOVED:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Effect: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::Effect valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::Effect>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
        return ::gtfsrealtime::Effect(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Effect: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::Effect>(::gtfsrealtime::Effect value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Effect value)
{
    contextNode.getContext().init(::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::Effect value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::Effect value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::Effect value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::Effect value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::Effect read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Effect>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(
                    in.readVarUInt16()));
}

template <>
::gtfsrealtime::Effect read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::Effect>(contextNode.getContext().read(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::Effect value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::Effect value)
{
    contextNode.getContext().write(
            ::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::gtfsrealtime::Effect>::type>(),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <gtfsrealtime/ScheduleRelationship.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ScheduleRelationship enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::gtfsrealtime::ScheduleRelationship>::names;
constexpr ::std::array<::gtfsrealtime::ScheduleRelationship, 4> EnumTraits<::gtfsrealtime::ScheduleRelationship>::values;

template <>
size_t enumToOrdinal(::gtfsrealtime::ScheduleRelationship value)
{
    switch (value)
    {
    case ::gtfsrealtime::ScheduleRelationship::SCHEDULED:
        return 0;
    case ::gtfsrealtime::ScheduleRelationship::ADDED:
        return 1;
    case ::gtfsrealtime::ScheduleRelationship::UNSCHEDULED:
        return 2;
    case ::gtfsrealtime::ScheduleRelationship::CANCELED:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ScheduleRelationship: ") <<
                static_cast<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(value) << "!";
    }
}

template <>
::gtfsrealtime::ScheduleRelationship valueToEnum(
        typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return ::gtfsrealtime::ScheduleRelationship(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ScheduleRelationship: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::gtfsrealtime::ScheduleRelationship>(::gtfsrealtime::ScheduleRelationship value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::ScheduleRelationship value)
{
    contextNode.getContext().init(::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::gtfsrealtime::ScheduleRelationship)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::PackingContextNode& contextNode, ::gtfsrealtime::ScheduleRelationship value)
{
    return contextNode.getContext().bitSizeOf(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(UINT8_C(4)),
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::gtfsrealtime::ScheduleRelationship value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::PackingContextNode& contextNode,
        size_t bitPosition, ::gtfsrealtime::ScheduleRelationship value)
{
    return bitPosition + bitSizeOf(contextNode, value);
}

template <>
::gtfsrealtime::ScheduleRelationship read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::ScheduleRelationship>(
            static_cast<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::gtfsrealtime::ScheduleRelationship read(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::gtfsrealtime::ScheduleRelationship>(contextNode.getContext().read(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(UINT8_C(4)), in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::gtfsrealtime::ScheduleRelationship value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out, ::gtfsrealtime::ScheduleRelationship value)
{
    contextNode.getContext().write(
            ::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::gtfsrealtime::ScheduleRelationship>::type>(UINT8_C(4)),
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <functional>

#include <gtfsrealtime/FeedMessage.h>

namespace gtfsrealtime
{

FeedMessage::ZserioElementFactory_entity::ZserioElementFactory_entity(FeedMessage& owner) :
        m_ownerRef(owner)
{}

void FeedMessage::ZserioElementFactory_entity::create(::zserio::vector<::gtfsrealtime::FeedEntity>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, array.get_allocator());
}

void FeedMessage::ZserioElementFactory_entity::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::gtfsrealtime::FeedEntity>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, array.get_allocator());
}

FeedMessage::FeedMessage(const allocator_type& allocator) noexcept :
        m_header_(allocator),
        m_entity_(::zserio::ObjectArrayTraits<::gtfsrealtime::FeedEntity, ZserioElementFactory_entity>(), allocator)
{
}

FeedMessage::FeedMessage(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_header_(readHeader(in, allocator)),
        m_entity_(readEntity(in, allocator))
{
}

FeedMessage::FeedMessage(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_header_(readHeader(contextNode, in, allocator)),
        m_entity_(readEntity(contextNode, in, allocator))
{
}

FeedMessage::FeedMessage(::zserio::PropagateAllocatorT,
        const FeedMessage& other, const allocator_type& allocator) :
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_entity_(::zserio::allocatorPropagatingCopy(other.m_entity_, allocator))
{
}

::gtfsrealtime::FeedHeader& FeedMessage::getHeader()
{
    return m_header_;
}

const ::gtfsrealtime::FeedHeader& FeedMessage::getHeader() const
{
    return m_header_;
}

void FeedMessage::setHeader(const ::gtfsrealtime::FeedHeader& header_)
{
    m_header_ = header_;
}

void FeedMessage::setHeader(::gtfsrealtime::FeedHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::gtfsrealtime::FeedEntity>& FeedMessage::getEntity()
{
    return m_entity_.getRawArray();
}

const ::zserio::vector<::gtfsrealtime::FeedEntity>& FeedMessage::getEntity() const
{
    return m_entity_.getRawArray();
}

void FeedMessage::setEntity(const ::zserio::vector<::gtfsrealtime::FeedEntity>& entity_)
{
    m_entity_ = ZserioArrayType_entity(entity_, ::zserio::ObjectArrayTraits<::gtfsrealtime::FeedEntity, ZserioElementFactory_entity>());
}

void FeedMessage::setEntity(::zserio::vector<::gtfsrealtime::FeedEntity>&& entity_)
{
    m_entity_ = ZserioArrayType_entity(std::move(entity_), ::zserio::ObjectArrayTraits<::gtfsrealtime::FeedEntity, ZserioElementFactory_entity>());
}

void FeedMessage::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    ::gtfsrealtime::FeedHeader::createPackingContext(contextNode.createChild());
    contextNode.createChild();
}

void FeedMessage::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    m_header_.initPackingContext(contextNode.getChildren().at(0));
}

size_t FeedMessage::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_entity_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FeedMessage::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(
            contextNode.getChildren().at(0), endBitPosition);
    endBitPosition += m_entity_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t FeedMessage::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_entity_.initializeOffsets(
            endBitPosition);

    return endBitPosition;
}

size_t FeedMessage::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(
            contextNode.getChildren().at(0), endBitPosition);
    endBitPosition = m_entity_.initializeOffsetsPacked(
            endBitPosition);

    return endBitPosition;
}

bool FeedMessage::operator==(const FeedMessage& other) const
{
    if (this != &other)
    {
        return
                (m_header_ == other.m_header_) &&
                (m_entity_ == other.m_entity_);
    }

    return true;
}

uint32_t FeedMessage::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_entity_);

    return result;
}

void FeedMessage::write(::zserio::BitStreamWriter& out) const
{
    m_header_.write(out);
    m_entity_.write(out);
}

void FeedMessage::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    m_header_.write(contextNode.getChildren().at(0), out);
    m_entity_.writePacked(out);
}

::gtfsrealtime::FeedHeader FeedMessage::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::gtfsrealtime::FeedHeader(in, allocator);
}

::gtfsrealtime::FeedHeader FeedMessage::readHeader(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::gtfsrealtime::FeedHeader(contextNode.getChildren().at(0), in, allocator);
}

FeedMessage::ZserioArrayType_entity FeedMessage::readEntity(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_entity readField(::zserio::ObjectArrayTraits<::gtfsrealtime::FeedEntity, ZserioElementFactory_entity>(), allocator);
    readField.read(in, ZserioElementFactory_entity(*this));

    return readField;
}

FeedMessage::ZserioArrayType_entity FeedMessage::readEntity(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_entity readField(::zserio::ObjectArrayTraits<::gtfsrealtime::FeedEntity, ZserioElementFactory_entity>(), allocator);
    readField.readPacked(in, ZserioElementFactory_entity(*this));

    return readField;
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <gtfsrealtime/FeedHeader.h>
#include <gtfsrealtime/Incrementality.h>

namespace gtfsrealtime
{

FeedHeader::FeedHeader(const allocator_type& allocator) noexcept :
        m_gtfs_realtime_version_(allocator),
        m_incrementality_(static_cast<::gtfsrealtime::Incrementality>(::gtfsrealtime::Incrementality::FULL_DATASET)),
        m_timestamp_(::zserio::NullOpt)
{
}

FeedHeader::FeedHeader(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_gtfs_realtime_version_(readGtfs_realtime_version(in, allocator)),
        m_incrementality_(readIncrementality(in)),
        m_timestamp_(readTimestamp(in))
{
}

FeedHeader::FeedHeader(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_gtfs_realtime_version_(readGtfs_realtime_version(in, allocator)),
        m_incrementality_(readIncrementality(contextNode, in)),
        m_timestamp_(readTimestamp(contextNode, in))
{
}

FeedHeader::FeedHeader(::zserio::PropagateAllocatorT,
        const FeedHeader& other, const allocator_type& allocator) :
        m_gtfs_realtime_version_(::zserio::allocatorPropagatingCopy(other.m_gtfs_realtime_version_, allocator)),
        m_incrementality_(::zserio::allocatorPropagatingCopy(other.m_incrementality_, allocator)),
        m_timestamp_(::zserio::allocatorPropagatingCopy(other.m_timestamp_, allocator))
{
}

::zserio::string<>& FeedHeader::getGtfs_realtime_version()
{
    return m_gtfs_realtime_version_;
}

const ::zserio::string<>& FeedHeader::getGtfs_realtime_version() const
{
    return m_gtfs_realtime_version_;
}

void FeedHeader::setGtfs_realtime_version(const ::zserio::string<>& gtfs_realtime_version_)
{
    m_gtfs_realtime_version_ = gtfs_realtime_version_;
}

void FeedHeader::setGtfs_realtime_version(::zserio::string<>&& gtfs_realtime_version_)
{
    m_gtfs_realtime_version_ = ::std::move(gtfs_realtime_version_);
}

::gtfsrealtime::Incrementality FeedHeader::getIncrementality() const
{
    return m_incrementality_;
}

void FeedHeader::setIncrementality(::gtfsrealtime::Incrementality incrementality_)
{
    m_incrementality_ = incrementality_;
}

uint64_t FeedHeader::getTimestamp() const
{
    return m_timestamp_.value();
}

void FeedHeader::setTimestamp(uint64_t timestamp_)
{
    m_timestamp_ = timestamp_;
}

bool FeedHeader::isTimestampUsed() const
{
    return (isTimestampSet());
}

bool FeedHeader::isTimestampSet() const
{
    return m_timestamp_.hasValue();
}

void FeedHeader::resetTimestamp()
{
    m_timestamp_.reset();
}

void FeedHeader::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
}

void FeedHeader::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    ::zserio::initPackingContext(contextNode.getChildren().at(1),
            m_incrementality_);
    if (isTimestampSet())
    {
        contextNode.getChildren().at(2).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
}

size_t FeedHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_gtfs_realtime_version_);
    endBitPosition += ::zserio::bitSizeOf(m_incrementality_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }

    return endBitPosition - bitPosition;
}

size_t FeedHeader::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_gtfs_realtime_version_);
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(1), m_incrementality_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }

    return endBitPosition - bitPosition;
}

size_t FeedHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_gtfs_realtime_version_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_incrementality_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }

    return endBitPosition;
}

size_t FeedHeader::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_gtfs_realtime_version_);
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(1), endBitPosition, m_incrementality_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }

    return endBitPosition;
}

bool FeedHeader::operator==(const FeedHeader& other) const
{
    if (this != &other)
    {
        return
                (m_gtfs_realtime_version_ == other.m_gtfs_realtime_version_) &&
                (m_incrementality_ == other.m_incrementality_) &&
                ((!isTimestampUsed()) ? !other.isTimestampUsed() : (m_timestamp_ == other.m_timestamp_));
    }

    return true;
}

uint32_t FeedHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_gtfs_realtime_version_);
    result = ::zserio::calcHashCode(result, m_incrementality_);
    if (isTimestampUsed())
        result = ::zserio::calcHashCode(result, m_timestamp_);

    return result;
}

void FeedHeader::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_gtfs_realtime_version_);
    ::zserio::write(out, m_incrementality_);
    if (isTimestampSet())
    {
        out.writeBool(true);
        out.writeVarUInt64(m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void FeedHeader::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_gtfs_realtime_version_);
    ::zserio::write(contextNode.getChildren().at(1), out, m_incrementality_);
    if (isTimestampSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(2).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), out, m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::string<> FeedHeader::readGtfs_realtime_version(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

::gtfsrealtime::Incrementality FeedHeader::readIncrementality(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Incrementality>(in);
}

::gtfsrealtime::Incrementality FeedHeader::readIncrementality(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Incrementality>(contextNode.getChildren().at(1), in);
}

::zserio::InplaceOptionalHolder<uint64_t> FeedHeader::readTimestamp(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> FeedHeader::readTimestamp(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(contextNode.getChildren().at(2).getContext().read(::zserio::VarIntNNArrayTraits<uint64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/FeedEntity.h>

namespace gtfsrealtime
{

FeedEntity::FeedEntity(const allocator_type& allocator) noexcept :
        m_id_(allocator),
        m_is_deleted_(static_cast<bool>(false)),
        m_trip_update_(::zserio::NullOpt),
        m_vehicle_(::zserio::NullOpt),
        m_alert_(::zserio::NullOpt)
{
}

FeedEntity::FeedEntity(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_is_deleted_(readIs_deleted(in)),
        m_trip_update_(readTrip_update(in, allocator)),
        m_vehicle_(readVehicle(in, allocator)),
        m_alert_(readAlert(in, allocator))
{
}

FeedEntity::FeedEntity(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_is_deleted_(readIs_deleted(in)),
        m_trip_update_(readTrip_update(contextNode, in, allocator)),
        m_vehicle_(readVehicle(contextNode, in, allocator)),
        m_alert_(readAlert(contextNode, in, allocator))
{
}

FeedEntity::FeedEntity(::zserio::PropagateAllocatorT,
        const FeedEntity& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_is_deleted_(::zserio::allocatorPropagatingCopy(other.m_is_deleted_, allocator)),
        m_trip_update_(::zserio::allocatorPropagatingCopy(other.m_trip_update_, allocator)),
        m_vehicle_(::zserio::allocatorPropagatingCopy(other.m_vehicle_, allocator)),
        m_alert_(::zserio::allocatorPropagatingCopy(other.m_alert_, allocator))
{
}

::zserio::string<>& FeedEntity::getId()
{
    return m_id_;
}

const ::zserio::string<>& FeedEntity::getId() const
{
    return m_id_;
}

void FeedEntity::setId(const ::zserio::string<>& id_)
{
    m_id_ = id_;
}

void FeedEntity::setId(::zserio::string<>&& id_)
{
    m_id_ = ::std::move(id_);
}

bool FeedEntity::getIs_deleted() const
{
    return m_is_deleted_;
}

void FeedEntity::setIs_deleted(bool is_deleted_)
{
    m_is_deleted_ = is_deleted_;
}

::gtfsrealtime::TripUpdate& FeedEntity::getTrip_update()
{
    return m_trip_update_.value();
}

const ::gtfsrealtime::TripUpdate& FeedEntity::getTrip_update() const
{
    return m_trip_update_.value();
}

void FeedEntity::setTrip_update(const ::gtfsrealtime::TripUpdate& trip_update_)
{
    m_trip_update_ = trip_update_;
}

void FeedEntity::setTrip_update(::gtfsrealtime::TripUpdate&& trip_update_)
{
    m_trip_update_ = ::std::move(trip_update_);
}

bool FeedEntity::isTrip_updateUsed() const
{
    return (isTrip_updateSet());
}

bool FeedEntity::isTrip_updateSet() const
{
    return m_trip_update_.hasValue();
}

void FeedEntity::resetTrip_update()
{
    m_trip_update_.reset();
}

::gtfsrealtime::VehiclePosition& FeedEntity::getVehicle()
{
    return m_vehicle_.value();
}

const ::gtfsrealtime::VehiclePosition& FeedEntity::getVehicle() const
{
    return m_vehicle_.value();
}

void FeedEntity::setVehicle(const ::gtfsrealtime::VehiclePosition& vehicle_)
{
    m_vehicle_ = vehicle_;
}

void FeedEntity::setVehicle(::gtfsrealtime::VehiclePosition&& vehicle_)
{
    m_vehicle_ = ::std::move(vehicle_);
}

bool FeedEntity::isVehicleUsed() const
{
    return (isVehicleSet());
}

bool FeedEntity::isVehicleSet() const
{
    return m_vehicle_.hasValue();
}

void FeedEntity::resetVehicle()
{
    m_vehicle_.reset();
}

::gtfsrealtime::Alert& FeedEntity::getAlert()
{
    return m_alert_.value();
}

const ::gtfsrealtime::Alert& FeedEntity::getAlert() const
{
    return m_alert_.value();
}

void FeedEntity::setAlert(const ::gtfsrealtime::Alert& alert_)
{
    m_alert_ = alert_;
}

void FeedEntity::setAlert(::gtfsrealtime::Alert&& alert_)
{
    m_alert_ = ::std::move(alert_);
}

bool FeedEntity::isAlertUsed() const
{
    return (isAlertSet());
}

bool FeedEntity::isAlertSet() const
{
    return m_alert_.hasValue();
}

void FeedEntity::resetAlert()
{
    m_alert_.reset();
}

void FeedEntity::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    ::gtfsrealtime::TripUpdate::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::VehiclePosition::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::Alert::createPackingContext(contextNode.createChild());
}

void FeedEntity::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isTrip_updateSet())
    {
        m_trip_update_.value().initPackingContext(contextNode.getChildren().at(2));
    }
    if (isVehicleSet())
    {
        m_vehicle_.value().initPackingContext(contextNode.getChildren().at(3));
    }
    if (isAlertSet())
    {
        m_alert_.value().initPackingContext(contextNode.getChildren().at(4));
    }
}

size_t FeedEntity::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isTrip_updateSet())
    {
        endBitPosition += m_trip_update_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isAlertSet())
    {
        endBitPosition += m_alert_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t FeedEntity::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isTrip_updateSet())
    {
        endBitPosition += m_trip_update_.value().bitSizeOf(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition += 1;
    if (isAlertSet())
    {
        endBitPosition += m_alert_.value().bitSizeOf(
                contextNode.getChildren().at(4), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t FeedEntity::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isTrip_updateSet())
    {
        endBitPosition = m_trip_update_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isAlertSet())
    {
        endBitPosition = m_alert_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t FeedEntity::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_id_);
    endBitPosition += UINT8_C(1);
    endBitPosition += 1;
    if (isTrip_updateSet())
    {
        endBitPosition = m_trip_update_.value().initializeOffsets(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition += 1;
    if (isAlertSet())
    {
        endBitPosition = m_alert_.value().initializeOffsets(
                contextNode.getChildren().at(4), endBitPosition);
    }

    return endBitPosition;
}

bool FeedEntity::operator==(const FeedEntity& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_is_deleted_ == other.m_is_deleted_) &&
                ((!isTrip_updateUsed()) ? !other.isTrip_updateUsed() : (m_trip_update_ == other.m_trip_update_)) &&
                ((!isVehicleUsed()) ? !other.isVehicleUsed() : (m_vehicle_ == other.m_vehicle_)) &&
                ((!isAlertUsed()) ? !other.isAlertUsed() : (m_alert_ == other.m_alert_));
    }

    return true;
}

uint32_t FeedEntity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_is_deleted_);
    if (isTrip_updateUsed())
        result = ::zserio::calcHashCode(result, m_trip_update_);
    if (isVehicleUsed())
        result = ::zserio::calcHashCode(result, m_vehicle_);
    if (isAlertUsed())
        result = ::zserio::calcHashCode(result, m_alert_);

    return result;
}

void FeedEntity::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_id_);
    out.writeBool(m_is_deleted_);
    if (isTrip_updateSet())
    {
        out.writeBool(true);
        m_trip_update_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isAlertSet())
    {
        out.writeBool(true);
        m_alert_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void FeedEntity::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_id_);
    out.writeBool(m_is_deleted_);
    if (isTrip_updateSet())
    {
        out.writeBool(true);
        m_trip_update_.value().write(contextNode.getChildren().at(2), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(contextNode.getChildren().at(3), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isAlertSet())
    {
        out.writeBool(true);
        m_alert_.value().write(contextNode.getChildren().at(4), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::string<> FeedEntity::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

bool FeedEntity::readIs_deleted(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate> FeedEntity::readTrip_update(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate>(::gtfsrealtime::TripUpdate(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate> FeedEntity::readTrip_update(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate>(::gtfsrealtime::TripUpdate(contextNode.getChildren().at(2), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripUpdate>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition> FeedEntity::readVehicle(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition>(::gtfsrealtime::VehiclePosition(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition> FeedEntity::readVehicle(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition>(::gtfsrealtime::VehiclePosition(contextNode.getChildren().at(3), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehiclePosition>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert> FeedEntity::readAlert(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert>(::gtfsrealtime::Alert(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert> FeedEntity::readAlert(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert>(::gtfsrealtime::Alert(contextNode.getChildren().at(4), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Alert>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <functional>

#include <gtfsrealtime/TripUpdate.h>

namespace gtfsrealtime
{

TripUpdate::ZserioElementFactory_stop_time_update::ZserioElementFactory_stop_time_update(TripUpdate& owner) :
        m_ownerRef(owner)
{}

void TripUpdate::ZserioElementFactory_stop_time_update::create(::zserio::vector<::gtfsrealtime::StopTimeUpdate>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, array.get_allocator());
}

void TripUpdate::ZserioElementFactory_stop_time_update::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::gtfsrealtime::StopTimeUpdate>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, array.get_allocator());
}

TripUpdate::TripUpdate(const allocator_type& allocator) noexcept :
        m_trip_(allocator),
        m_vehicle_(::zserio::NullOpt),
        m_stop_time_update_(::zserio::ObjectArrayTraits<::gtfsrealtime::StopTimeUpdate, ZserioElementFactory_stop_time_update>(), allocator),
        m_timestamp_(::zserio::NullOpt),
        m_delay_(::zserio::NullOpt)
{
}

TripUpdate::TripUpdate(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_(readTrip(in, allocator)),
        m_vehicle_(readVehicle(in, allocator)),
        m_stop_time_update_(readStop_time_update(in, allocator)),
        m_timestamp_(readTimestamp(in)),
        m_delay_(readDelay(in))
{
}

TripUpdate::TripUpdate(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_(readTrip(contextNode, in, allocator)),
        m_vehicle_(readVehicle(contextNode, in, allocator)),
        m_stop_time_update_(readStop_time_update(contextNode, in, allocator)),
        m_timestamp_(readTimestamp(contextNode, in)),
        m_delay_(readDelay(contextNode, in))
{
}

TripUpdate::TripUpdate(::zserio::PropagateAllocatorT,
        const TripUpdate& other, const allocator_type& allocator) :
        m_trip_(::zserio::allocatorPropagatingCopy(other.m_trip_, allocator)),
        m_vehicle_(::zserio::allocatorPropagatingCopy(other.m_vehicle_, allocator)),
        m_stop_time_update_(::zserio::allocatorPropagatingCopy(other.m_stop_time_update_, allocator)),
        m_timestamp_(::zserio::allocatorPropagatingCopy(other.m_timestamp_, allocator)),
        m_delay_(::zserio::allocatorPropagatingCopy(other.m_delay_, allocator))
{
}

::gtfsrealtime::TripDescriptor& TripUpdate::getTrip()
{
    return m_trip_;
}

const ::gtfsrealtime::TripDescriptor& TripUpdate::getTrip() const
{
    return m_trip_;
}

void TripUpdate::setTrip(const ::gtfsrealtime::TripDescriptor& trip_)
{
    m_trip_ = trip_;
}

void TripUpdate::setTrip(::gtfsrealtime::TripDescriptor&& trip_)
{
    m_trip_ = ::std::move(trip_);
}

::gtfsrealtime::VehicleDescriptor& TripUpdate::getVehicle()
{
    return m_vehicle_.value();
}

const ::gtfsrealtime::VehicleDescriptor& TripUpdate::getVehicle() const
{
    return m_vehicle_.value();
}

void TripUpdate::setVehicle(const ::gtfsrealtime::VehicleDescriptor& vehicle_)
{
    m_vehicle_ = vehicle_;
}

void TripUpdate::setVehicle(::gtfsrealtime::VehicleDescriptor&& vehicle_)
{
    m_vehicle_ = ::std::move(vehicle_);
}

bool TripUpdate::isVehicleUsed() const
{
    return (isVehicleSet());
}

bool TripUpdate::isVehicleSet() const
{
    return m_vehicle_.hasValue();
}

void TripUpdate::resetVehicle()
{
    m_vehicle_.reset();
}

::zserio::vector<::gtfsrealtime::StopTimeUpdate>& TripUpdate::getStop_time_update()
{
    return m_stop_time_update_.getRawArray();
}

const ::zserio::vector<::gtfsrealtime::StopTimeUpdate>& TripUpdate::getStop_time_update() const
{
    return m_stop_time_update_.getRawArray();
}

void TripUpdate::setStop_time_update(const ::zserio::vector<::gtfsrealtime::StopTimeUpdate>& stop_time_update_)
{
    m_stop_time_update_ = ZserioArrayType_stop_time_update(stop_time_update_, ::zserio::ObjectArrayTraits<::gtfsrealtime::StopTimeUpdate, ZserioElementFactory_stop_time_update>());
}

void TripUpdate::setStop_time_update(::zserio::vector<::gtfsrealtime::StopTimeUpdate>&& stop_time_update_)
{
    m_stop_time_update_ = ZserioArrayType_stop_time_update(std::move(stop_time_update_), ::zserio::ObjectArrayTraits<::gtfsrealtime::StopTimeUpdate, ZserioElementFactory_stop_time_update>());
}

uint64_t TripUpdate::getTimestamp() const
{
    return m_timestamp_.value();
}

void TripUpdate::setTimestamp(uint64_t timestamp_)
{
    m_timestamp_ = timestamp_;
}

bool TripUpdate::isTimestampUsed() const
{
    return (isTimestampSet());
}

bool TripUpdate::isTimestampSet() const
{
    return m_timestamp_.hasValue();
}

void TripUpdate::resetTimestamp()
{
    m_timestamp_.reset();
}

int32_t TripUpdate::getDelay() const
{
    return m_delay_.value();
}

void TripUpdate::setDelay(int32_t delay_)
{
    m_delay_ = delay_;
}

bool TripUpdate::isDelayUsed() const
{
    return (isDelaySet());
}

bool TripUpdate::isDelaySet() const
{
    return m_delay_.hasValue();
}

void TripUpdate::resetDelay()
{
    m_delay_.reset();
}

void TripUpdate::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    ::gtfsrealtime::TripDescriptor::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::VehicleDescriptor::createPackingContext(contextNode.createChild());
    contextNode.createChild();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
}

void TripUpdate::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    m_trip_.initPackingContext(contextNode.getChildren().at(0));
    if (isVehicleSet())
    {
        m_vehicle_.value().initPackingContext(contextNode.getChildren().at(1));
    }
    if (isTimestampSet())
    {
        contextNode.getChildren().at(3).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    if (isDelaySet())
    {
        contextNode.getChildren().at(4).getContext().init(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }
}

size_t TripUpdate::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_trip_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += m_stop_time_update_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_delay_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TripUpdate::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_trip_.bitSizeOf(
            contextNode.getChildren().at(0), endBitPosition);
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(
                contextNode.getChildren().at(1), endBitPosition);
    }
    endBitPosition += m_stop_time_update_.bitSizeOfPacked(endBitPosition);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(3).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += contextNode.getChildren().at(4).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TripUpdate::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_trip_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = m_stop_time_update_.initializeOffsets(
            endBitPosition);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_delay_.value());
    }

    return endBitPosition;
}

size_t TripUpdate::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_trip_.initializeOffsets(
            contextNode.getChildren().at(0), endBitPosition);
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(
                contextNode.getChildren().at(1), endBitPosition);
    }
    endBitPosition = m_stop_time_update_.initializeOffsetsPacked(
            endBitPosition);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(3).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += contextNode.getChildren().at(4).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }

    return endBitPosition;
}

bool TripUpdate::operator==(const TripUpdate& other) const
{
    if (this != &other)
    {
        return
                (m_trip_ == other.m_trip_) &&
                ((!isVehicleUsed()) ? !other.isVehicleUsed() : (m_vehicle_ == other.m_vehicle_)) &&
                (m_stop_time_update_ == other.m_stop_time_update_) &&
                ((!isTimestampUsed()) ? !other.isTimestampUsed() : (m_timestamp_ == other.m_timestamp_)) &&
                ((!isDelayUsed()) ? !other.isDelayUsed() : (m_delay_ == other.m_delay_));
    }

    return true;
}

uint32_t TripUpdate::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_trip_);
    if (isVehicleUsed())
        result = ::zserio::calcHashCode(result, m_vehicle_);
    result = ::zserio::calcHashCode(result, m_stop_time_update_);
    if (isTimestampUsed())
        result = ::zserio::calcHashCode(result, m_timestamp_);
    if (isDelayUsed())
        result = ::zserio::calcHashCode(result, m_delay_);

    return result;
}

void TripUpdate::write(::zserio::BitStreamWriter& out) const
{
    m_trip_.write(out);
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    m_stop_time_update_.write(out);
    if (isTimestampSet())
    {
        out.writeBool(true);
        out.writeVarUInt64(m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDelaySet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_delay_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void TripUpdate::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    m_trip_.write(contextNode.getChildren().at(0), out);
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(contextNode.getChildren().at(1), out);
    }
    else
    {
        out.writeBool(false);
    }
    m_stop_time_update_.writePacked(out);
    if (isTimestampSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(3).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), out, m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDelaySet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(4).getContext().write(
                ::zserio::VarIntNNArrayTraits<int32_t>(), out, m_delay_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::gtfsrealtime::TripDescriptor TripUpdate::readTrip(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::gtfsrealtime::TripDescriptor(in, allocator);
}

::gtfsrealtime::TripDescriptor TripUpdate::readTrip(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::gtfsrealtime::TripDescriptor(contextNode.getChildren().at(0), in, allocator);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor> TripUpdate::readVehicle(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::gtfsrealtime::VehicleDescriptor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor> TripUpdate::readVehicle(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::gtfsrealtime::VehicleDescriptor(contextNode.getChildren().at(1), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::zserio::NullOpt);
}

TripUpdate::ZserioArrayType_stop_time_update TripUpdate::readStop_time_update(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_stop_time_update readField(::zserio::ObjectArrayTraits<::gtfsrealtime::StopTimeUpdate, ZserioElementFactory_stop_time_update>(), allocator);
    readField.read(in, ZserioElementFactory_stop_time_update(*this));

    return readField;
}

TripUpdate::ZserioArrayType_stop_time_update TripUpdate::readStop_time_update(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_stop_time_update readField(::zserio::ObjectArrayTraits<::gtfsrealtime::StopTimeUpdate, ZserioElementFactory_stop_time_update>(), allocator);
    readField.readPacked(in, ZserioElementFactory_stop_time_update(*this));

    return readField;
}

::zserio::InplaceOptionalHolder<uint64_t> TripUpdate::readTimestamp(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> TripUpdate::readTimestamp(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(contextNode.getChildren().at(3).getContext().read(::zserio::VarIntNNArrayTraits<uint64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> TripUpdate::readDelay(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(static_cast<int32_t>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> TripUpdate::readDelay(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(contextNode.getChildren().at(4).getContext().read(::zserio::VarIntNNArrayTraits<int32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/StopTimeEvent.h>

namespace gtfsrealtime
{

StopTimeEvent::StopTimeEvent(const allocator_type&) noexcept :
        m_delay_(::zserio::NullOpt),
        m_time_(::zserio::NullOpt),
        m_uncertainty_(::zserio::NullOpt)
{
}

StopTimeEvent::StopTimeEvent(::zserio::BitStreamReader& in, const allocator_type&) :
        m_delay_(readDelay(in)),
        m_time_(readTime(in)),
        m_uncertainty_(readUncertainty(in))
{
}

StopTimeEvent::StopTimeEvent(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_delay_(readDelay(contextNode, in)),
        m_time_(readTime(contextNode, in)),
        m_uncertainty_(readUncertainty(contextNode, in))
{
}

StopTimeEvent::StopTimeEvent(::zserio::PropagateAllocatorT,
        const StopTimeEvent& other, const allocator_type& allocator) :
        m_delay_(::zserio::allocatorPropagatingCopy(other.m_delay_, allocator)),
        m_time_(::zserio::allocatorPropagatingCopy(other.m_time_, allocator)),
        m_uncertainty_(::zserio::allocatorPropagatingCopy(other.m_uncertainty_, allocator))
{
}

int32_t StopTimeEvent::getDelay() const
{
    return m_delay_.value();
}

void StopTimeEvent::setDelay(int32_t delay_)
{
    m_delay_ = delay_;
}

bool StopTimeEvent::isDelayUsed() const
{
    return (isDelaySet());
}

bool StopTimeEvent::isDelaySet() const
{
    return m_delay_.hasValue();
}

void StopTimeEvent::resetDelay()
{
    m_delay_.reset();
}

int64_t StopTimeEvent::getTime() const
{
    return m_time_.value();
}

void StopTimeEvent::setTime(int64_t time_)
{
    m_time_ = time_;
}

bool StopTimeEvent::isTimeUsed() const
{
    return (isTimeSet());
}

bool StopTimeEvent::isTimeSet() const
{
    return m_time_.hasValue();
}

void StopTimeEvent::resetTime()
{
    m_time_.reset();
}

int32_t StopTimeEvent::getUncertainty() const
{
    return m_uncertainty_.value();
}

void StopTimeEvent::setUncertainty(int32_t uncertainty_)
{
    m_uncertainty_ = uncertainty_;
}

bool StopTimeEvent::isUncertaintyUsed() const
{
    return (isUncertaintySet());
}

bool StopTimeEvent::isUncertaintySet() const
{
    return m_uncertainty_.hasValue();
}

void StopTimeEvent::resetUncertainty()
{
    m_uncertainty_.reset();
}

void StopTimeEvent::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
}

void StopTimeEvent::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isDelaySet())
    {
        contextNode.getChildren().at(0).getContext().init(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }
    if (isTimeSet())
    {
        contextNode.getChildren().at(1).getContext().init(
                ::zserio::VarIntNNArrayTraits<int64_t>(), m_time_.value());
    }
    if (isUncertaintySet())
    {
        contextNode.getChildren().at(2).getContext().init(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_uncertainty_.value());
    }
}

size_t StopTimeEvent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_delay_.value());
    }
    endBitPosition += 1;
    if (isTimeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt64(m_time_.value());
    }
    endBitPosition += 1;
    if (isUncertaintySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_uncertainty_.value());
    }

    return endBitPosition - bitPosition;
}

size_t StopTimeEvent::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }
    endBitPosition += 1;
    if (isTimeSet())
    {
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int64_t>(), m_time_.value());
    }
    endBitPosition += 1;
    if (isUncertaintySet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_uncertainty_.value());
    }

    return endBitPosition - bitPosition;
}

size_t StopTimeEvent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_delay_.value());
    }
    endBitPosition += 1;
    if (isTimeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt64(m_time_.value());
    }
    endBitPosition += 1;
    if (isUncertaintySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_uncertainty_.value());
    }

    return endBitPosition;
}

size_t StopTimeEvent::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isDelaySet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_delay_.value());
    }
    endBitPosition += 1;
    if (isTimeSet())
    {
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int64_t>(), m_time_.value());
    }
    endBitPosition += 1;
    if (isUncertaintySet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_uncertainty_.value());
    }

    return endBitPosition;
}

bool StopTimeEvent::operator==(const StopTimeEvent& other) const
{
    if (this != &other)
    {
        return
                ((!isDelayUsed()) ? !other.isDelayUsed() : (m_delay_ == other.m_delay_)) &&
                ((!isTimeUsed()) ? !other.isTimeUsed() : (m_time_ == other.m_time_)) &&
                ((!isUncertaintyUsed()) ? !other.isUncertaintyUsed() : (m_uncertainty_ == other.m_uncertainty_));
    }

    return true;
}

uint32_t StopTimeEvent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isDelayUsed())
        result = ::zserio::calcHashCode(result, m_delay_);
    if (isTimeUsed())
        result = ::zserio::calcHashCode(result, m_time_);
    if (isUncertaintyUsed())
        result = ::zserio::calcHashCode(result, m_uncertainty_);

    return result;
}

void StopTimeEvent::write(::zserio::BitStreamWriter& out) const
{
    if (isDelaySet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_delay_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isTimeSet())
    {
        out.writeBool(true);
        out.writeVarInt64(m_time_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isUncertaintySet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_uncertainty_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void StopTimeEvent::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isDelaySet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(0).getContext().write(
                ::zserio::VarIntNNArrayTraits<int32_t>(), out, m_delay_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isTimeSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(1).getContext().write(
                ::zserio::VarIntNNArrayTraits<int64_t>(), out, m_time_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isUncertaintySet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(2).getContext().write(
                ::zserio::VarIntNNArrayTraits<int32_t>(), out, m_uncertainty_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<int32_t> StopTimeEvent::readDelay(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(static_cast<int32_t>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> StopTimeEvent::readDelay(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(contextNode.getChildren().at(0).getContext().read(::zserio::VarIntNNArrayTraits<int32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int64_t> StopTimeEvent::readTime(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int64_t>(static_cast<int64_t>(in.readVarInt64()));
    }

    return ::zserio::InplaceOptionalHolder<int64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int64_t> StopTimeEvent::readTime(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int64_t>(contextNode.getChildren().at(1).getContext().read(::zserio::VarIntNNArrayTraits<int64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<int64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> StopTimeEvent::readUncertainty(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(static_cast<int32_t>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> StopTimeEvent::readUncertainty(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(contextNode.getChildren().at(2).getContext().read(::zserio::VarIntNNArrayTraits<int32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <gtfsrealtime/StopTimeUpdate.h>
#include <gtfsrealtime/StopTimeScheduleRelationship.h>

namespace gtfsrealtime
{

StopTimeUpdate::StopTimeUpdate(const allocator_type&) noexcept :
        m_stop_sequence_(::zserio::NullOpt),
        m_stop_id_(::zserio::NullOpt),
        m_arrival_(::zserio::NullOpt),
        m_departure_(::zserio::NullOpt),
        m_schedule_relationship_(static_cast<::gtfsrealtime::StopTimeScheduleRelationship>(::gtfsrealtime::StopTimeScheduleRelationship::SCHEDULED))
{
}

StopTimeUpdate::StopTimeUpdate(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stop_sequence_(readStop_sequence(in)),
        m_stop_id_(readStop_id(in, allocator)),
        m_arrival_(readArrival(in, allocator)),
        m_departure_(readDeparture(in, allocator)),
        m_schedule_relationship_(readSchedule_relationship(in))
{
}

StopTimeUpdate::StopTimeUpdate(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_stop_sequence_(readStop_sequence(contextNode, in)),
        m_stop_id_(readStop_id(in, allocator)),
        m_arrival_(readArrival(contextNode, in, allocator)),
        m_departure_(readDeparture(contextNode, in, allocator)),
        m_schedule_relationship_(readSchedule_relationship(contextNode, in))
{
}

StopTimeUpdate::StopTimeUpdate(::zserio::PropagateAllocatorT,
        const StopTimeUpdate& other, const allocator_type& allocator) :
        m_stop_sequence_(::zserio::allocatorPropagatingCopy(other.m_stop_sequence_, allocator)),
        m_stop_id_(::zserio::allocatorPropagatingCopy(other.m_stop_id_, allocator)),
        m_arrival_(::zserio::allocatorPropagatingCopy(other.m_arrival_, allocator)),
        m_departure_(::zserio::allocatorPropagatingCopy(other.m_departure_, allocator)),
        m_schedule_relationship_(::zserio::allocatorPropagatingCopy(other.m_schedule_relationship_, allocator))
{
}

uint32_t StopTimeUpdate::getStop_sequence() const
{
    return m_stop_sequence_.value();
}

void StopTimeUpdate::setStop_sequence(uint32_t stop_sequence_)
{
    m_stop_sequence_ = stop_sequence_;
}

bool StopTimeUpdate::isStop_sequenceUsed() const
{
    return (isStop_sequenceSet());
}

bool StopTimeUpdate::isStop_sequenceSet() const
{
    return m_stop_sequence_.hasValue();
}

void StopTimeUpdate::resetStop_sequence()
{
    m_stop_sequence_.reset();
}

::zserio::string<>& StopTimeUpdate::getStop_id()
{
    return m_stop_id_.value();
}

const ::zserio::string<>& StopTimeUpdate::getStop_id() const
{
    return m_stop_id_.value();
}

void StopTimeUpdate::setStop_id(const ::zserio::string<>& stop_id_)
{
    m_stop_id_ = stop_id_;
}

void StopTimeUpdate::setStop_id(::zserio::string<>&& stop_id_)
{
    m_stop_id_ = ::std::move(stop_id_);
}

bool StopTimeUpdate::isStop_idUsed() const
{
    return (isStop_idSet());
}

bool StopTimeUpdate::isStop_idSet() const
{
    return m_stop_id_.hasValue();
}

void StopTimeUpdate::resetStop_id()
{
    m_stop_id_.reset();
}

::gtfsrealtime::StopTimeEvent& StopTimeUpdate::getArrival()
{
    return m_arrival_.value();
}

const ::gtfsrealtime::StopTimeEvent& StopTimeUpdate::getArrival() const
{
    return m_arrival_.value();
}

void StopTimeUpdate::setArrival(const ::gtfsrealtime::StopTimeEvent& arrival_)
{
    m_arrival_ = arrival_;
}

void StopTimeUpdate::setArrival(::gtfsrealtime::StopTimeEvent&& arrival_)
{
    m_arrival_ = ::std::move(arrival_);
}

bool StopTimeUpdate::isArrivalUsed() const
{
    return (isArrivalSet());
}

bool StopTimeUpdate::isArrivalSet() const
{
    return m_arrival_.hasValue();
}

void StopTimeUpdate::resetArrival()
{
    m_arrival_.reset();
}

::gtfsrealtime::StopTimeEvent& StopTimeUpdate::getDeparture()
{
    return m_departure_.value();
}

const ::gtfsrealtime::StopTimeEvent& StopTimeUpdate::getDeparture() const
{
    return m_departure_.value();
}

void StopTimeUpdate::setDeparture(const ::gtfsrealtime::StopTimeEvent& departure_)
{
    m_departure_ = departure_;
}

void StopTimeUpdate::setDeparture(::gtfsrealtime::StopTimeEvent&& departure_)
{
    m_departure_ = ::std::move(departure_);
}

bool StopTimeUpdate::isDepartureUsed() const
{
    return (isDepartureSet());
}

bool StopTimeUpdate::isDepartureSet() const
{
    return m_departure_.hasValue();
}

void StopTimeUpdate::resetDeparture()
{
    m_departure_.reset();
}

::gtfsrealtime::StopTimeScheduleRelationship StopTimeUpdate::getSchedule_relationship() const
{
    return m_schedule_relationship_;
}

void StopTimeUpdate::setSchedule_relationship(::gtfsrealtime::StopTimeScheduleRelationship schedule_relationship_)
{
    m_schedule_relationship_ = schedule_relationship_;
}

void StopTimeUpdate::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    contextNode.createChild();
    ::gtfsrealtime::StopTimeEvent::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::StopTimeEvent::createPackingContext(contextNode.createChild());
    contextNode.createChild().createContext();
}

void StopTimeUpdate::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isStop_sequenceSet())
    {
        contextNode.getChildren().at(0).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_stop_sequence_.value());
    }
    if (isArrivalSet())
    {
        m_arrival_.value().initPackingContext(contextNode.getChildren().at(2));
    }
    if (isDepartureSet())
    {
        m_departure_.value().initPackingContext(contextNode.getChildren().at(3));
    }
    ::zserio::initPackingContext(contextNode.getChildren().at(4),
            m_schedule_relationship_);
}

size_t StopTimeUpdate::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStop_sequenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += 1;
    if (isArrivalSet())
    {
        endBitPosition += m_arrival_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isDepartureSet())
    {
        endBitPosition += m_departure_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOf(m_schedule_relationship_);

    return endBitPosition - bitPosition;
}

size_t StopTimeUpdate::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStop_sequenceSet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += 1;
    if (isArrivalSet())
    {
        endBitPosition += m_arrival_.value().bitSizeOf(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isDepartureSet())
    {
        endBitPosition += m_departure_.value().bitSizeOf(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(4), m_schedule_relationship_);

    return endBitPosition - bitPosition;
}

size_t StopTimeUpdate::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStop_sequenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += 1;
    if (isArrivalSet())
    {
        endBitPosition = m_arrival_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isDepartureSet())
    {
        endBitPosition = m_departure_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_schedule_relationship_);

    return endBitPosition;
}

size_t StopTimeUpdate::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStop_sequenceSet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += 1;
    if (isArrivalSet())
    {
        endBitPosition = m_arrival_.value().initializeOffsets(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isDepartureSet())
    {
        endBitPosition = m_departure_.value().initializeOffsets(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(4), endBitPosition, m_schedule_relationship_);

    return endBitPosition;
}

bool StopTimeUpdate::operator==(const StopTimeUpdate& other) const
{
    if (this != &other)
    {
        return
                ((!isStop_sequenceUsed()) ? !other.isStop_sequenceUsed() : (m_stop_sequence_ == other.m_stop_sequence_)) &&
                ((!isStop_idUsed()) ? !other.isStop_idUsed() : (m_stop_id_ == other.m_stop_id_)) &&
                ((!isArrivalUsed()) ? !other.isArrivalUsed() : (m_arrival_ == other.m_arrival_)) &&
                ((!isDepartureUsed()) ? !other.isDepartureUsed() : (m_departure_ == other.m_departure_)) &&
                (m_schedule_relationship_ == other.m_schedule_relationship_);
    }

    return true;
}

uint32_t StopTimeUpdate::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isStop_sequenceUsed())
        result = ::zserio::calcHashCode(result, m_stop_sequence_);
    if (isStop_idUsed())
        result = ::zserio::calcHashCode(result, m_stop_id_);
    if (isArrivalUsed())
        result = ::zserio::calcHashCode(result, m_arrival_);
    if (isDepartureUsed())
        result = ::zserio::calcHashCode(result, m_departure_);
    result = ::zserio::calcHashCode(result, m_schedule_relationship_);

    return result;
}

void StopTimeUpdate::write(::zserio::BitStreamWriter& out) const
{
    if (isStop_sequenceSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_stop_sequence_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalSet())
    {
        out.writeBool(true);
        m_arrival_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDepartureSet())
    {
        out.writeBool(true);
        m_departure_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    ::zserio::write(out, m_schedule_relationship_);
}

void StopTimeUpdate::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isStop_sequenceSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(0).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), out, m_stop_sequence_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isArrivalSet())
    {
        out.writeBool(true);
        m_arrival_.value().write(contextNode.getChildren().at(2), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDepartureSet())
    {
        out.writeBool(true);
        m_departure_.value().write(contextNode.getChildren().at(3), out);
    }
    else
    {
        out.writeBool(false);
    }
    ::zserio::write(contextNode.getChildren().at(4), out, m_schedule_relationship_);
}

::zserio::InplaceOptionalHolder<uint32_t> StopTimeUpdate::readStop_sequence(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> StopTimeUpdate::readStop_sequence(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(contextNode.getChildren().at(0).getContext().read(::zserio::VarIntNNArrayTraits<uint32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> StopTimeUpdate::readStop_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent> StopTimeUpdate::readArrival(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::gtfsrealtime::StopTimeEvent(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent> StopTimeUpdate::readArrival(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::gtfsrealtime::StopTimeEvent(contextNode.getChildren().at(2), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent> StopTimeUpdate::readDeparture(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::gtfsrealtime::StopTimeEvent(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent> StopTimeUpdate::readDeparture(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::gtfsrealtime::StopTimeEvent(contextNode.getChildren().at(3), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::StopTimeEvent>(::zserio::NullOpt);
}

::gtfsrealtime::StopTimeScheduleRelationship StopTimeUpdate::readSchedule_relationship(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::StopTimeScheduleRelationship>(in);
}

::gtfsrealtime::StopTimeScheduleRelationship StopTimeUpdate::readSchedule_relationship(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::StopTimeScheduleRelationship>(contextNode.getChildren().at(4), in);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <gtfsrealtime/VehiclePosition.h>
#include <gtfsrealtime/VehicleStopStatus.h>

namespace gtfsrealtime
{

VehiclePosition::VehiclePosition(const allocator_type&) noexcept :
        m_trip_(::zserio::NullOpt),
        m_vehicle_(::zserio::NullOpt),
        m_position_(::zserio::NullOpt),
        m_current_stop_sequence_(::zserio::NullOpt),
        m_stop_id_(::zserio::NullOpt),
        m_current_status_(static_cast<::gtfsrealtime::VehicleStopStatus>(::gtfsrealtime::VehicleStopStatus::IN_TRANSIT_TO)),
        m_timestamp_(::zserio::NullOpt),
        m_congestion_level_(::zserio::NullOpt),
        m_occupancy_status_(::zserio::NullOpt)
{
}

VehiclePosition::VehiclePosition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_(readTrip(in, allocator)),
        m_vehicle_(readVehicle(in, allocator)),
        m_position_(readPosition(in, allocator)),
        m_current_stop_sequence_(readCurrent_stop_sequence(in)),
        m_stop_id_(readStop_id(in, allocator)),
        m_current_status_(readCurrent_status(in)),
        m_timestamp_(readTimestamp(in)),
        m_congestion_level_(readCongestion_level(in)),
        m_occupancy_status_(readOccupancy_status(in))
{
}

VehiclePosition::VehiclePosition(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_(readTrip(contextNode, in, allocator)),
        m_vehicle_(readVehicle(contextNode, in, allocator)),
        m_position_(readPosition(contextNode, in, allocator)),
        m_current_stop_sequence_(readCurrent_stop_sequence(contextNode, in)),
        m_stop_id_(readStop_id(in, allocator)),
        m_current_status_(readCurrent_status(contextNode, in)),
        m_timestamp_(readTimestamp(contextNode, in)),
        m_congestion_level_(readCongestion_level(contextNode, in)),
        m_occupancy_status_(readOccupancy_status(contextNode, in))
{
}

VehiclePosition::VehiclePosition(::zserio::PropagateAllocatorT,
        const VehiclePosition& other, const allocator_type& allocator) :
        m_trip_(::zserio::allocatorPropagatingCopy(other.m_trip_, allocator)),
        m_vehicle_(::zserio::allocatorPropagatingCopy(other.m_vehicle_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator)),
        m_current_stop_sequence_(::zserio::allocatorPropagatingCopy(other.m_current_stop_sequence_, allocator)),
        m_stop_id_(::zserio::allocatorPropagatingCopy(other.m_stop_id_, allocator)),
        m_current_status_(::zserio::allocatorPropagatingCopy(other.m_current_status_, allocator)),
        m_timestamp_(::zserio::allocatorPropagatingCopy(other.m_timestamp_, allocator)),
        m_congestion_level_(::zserio::allocatorPropagatingCopy(other.m_congestion_level_, allocator)),
        m_occupancy_status_(::zserio::allocatorPropagatingCopy(other.m_occupancy_status_, allocator))
{
}

::gtfsrealtime::TripDescriptor& VehiclePosition::getTrip()
{
    return m_trip_.value();
}

const ::gtfsrealtime::TripDescriptor& VehiclePosition::getTrip() const
{
    return m_trip_.value();
}

void VehiclePosition::setTrip(const ::gtfsrealtime::TripDescriptor& trip_)
{
    m_trip_ = trip_;
}

void VehiclePosition::setTrip(::gtfsrealtime::TripDescriptor&& trip_)
{
    m_trip_ = ::std::move(trip_);
}

bool VehiclePosition::isTripUsed() const
{
    return (isTripSet());
}

bool VehiclePosition::isTripSet() const
{
    return m_trip_.hasValue();
}

void VehiclePosition::resetTrip()
{
    m_trip_.reset();
}

::gtfsrealtime::VehicleDescriptor& VehiclePosition::getVehicle()
{
    return m_vehicle_.value();
}

const ::gtfsrealtime::VehicleDescriptor& VehiclePosition::getVehicle() const
{
    return m_vehicle_.value();
}

void VehiclePosition::setVehicle(const ::gtfsrealtime::VehicleDescriptor& vehicle_)
{
    m_vehicle_ = vehicle_;
}

void VehiclePosition::setVehicle(::gtfsrealtime::VehicleDescriptor&& vehicle_)
{
    m_vehicle_ = ::std::move(vehicle_);
}

bool VehiclePosition::isVehicleUsed() const
{
    return (isVehicleSet());
}

bool VehiclePosition::isVehicleSet() const
{
    return m_vehicle_.hasValue();
}

void VehiclePosition::resetVehicle()
{
    m_vehicle_.reset();
}

::gtfsrealtime::Position& VehiclePosition::getPosition()
{
    return m_position_.value();
}

const ::gtfsrealtime::Position& VehiclePosition::getPosition() const
{
    return m_position_.value();
}

void VehiclePosition::setPosition(const ::gtfsrealtime::Position& position_)
{
    m_position_ = position_;
}

void VehiclePosition::setPosition(::gtfsrealtime::Position&& position_)
{
    m_position_ = ::std::move(position_);
}

bool VehiclePosition::isPositionUsed() const
{
    return (isPositionSet());
}

bool VehiclePosition::isPositionSet() const
{
    return m_position_.hasValue();
}

void VehiclePosition::resetPosition()
{
    m_position_.reset();
}

uint32_t VehiclePosition::getCurrent_stop_sequence() const
{
    return m_current_stop_sequence_.value();
}

void VehiclePosition::setCurrent_stop_sequence(uint32_t current_stop_sequence_)
{
    m_current_stop_sequence_ = current_stop_sequence_;
}

bool VehiclePosition::isCurrent_stop_sequenceUsed() const
{
    return (isCurrent_stop_sequenceSet());
}

bool VehiclePosition::isCurrent_stop_sequenceSet() const
{
    return m_current_stop_sequence_.hasValue();
}

void VehiclePosition::resetCurrent_stop_sequence()
{
    m_current_stop_sequence_.reset();
}

::zserio::string<>& VehiclePosition::getStop_id()
{
    return m_stop_id_.value();
}

const ::zserio::string<>& VehiclePosition::getStop_id() const
{
    return m_stop_id_.value();
}

void VehiclePosition::setStop_id(const ::zserio::string<>& stop_id_)
{
    m_stop_id_ = stop_id_;
}

void VehiclePosition::setStop_id(::zserio::string<>&& stop_id_)
{
    m_stop_id_ = ::std::move(stop_id_);
}

bool VehiclePosition::isStop_idUsed() const
{
    return (isStop_idSet());
}

bool VehiclePosition::isStop_idSet() const
{
    return m_stop_id_.hasValue();
}

void VehiclePosition::resetStop_id()
{
    m_stop_id_.reset();
}

::gtfsrealtime::VehicleStopStatus VehiclePosition::getCurrent_status() const
{
    return m_current_status_;
}

void VehiclePosition::setCurrent_status(::gtfsrealtime::VehicleStopStatus current_status_)
{
    m_current_status_ = current_status_;
}

uint64_t VehiclePosition::getTimestamp() const
{
    return m_timestamp_.value();
}

void VehiclePosition::setTimestamp(uint64_t timestamp_)
{
    m_timestamp_ = timestamp_;
}

bool VehiclePosition::isTimestampUsed() const
{
    return (isTimestampSet());
}

bool VehiclePosition::isTimestampSet() const
{
    return m_timestamp_.hasValue();
}

void VehiclePosition::resetTimestamp()
{
    m_timestamp_.reset();
}

::gtfsrealtime::CongestionLevel VehiclePosition::getCongestion_level() const
{
    return m_congestion_level_.value();
}

void VehiclePosition::setCongestion_level(::gtfsrealtime::CongestionLevel congestion_level_)
{
    m_congestion_level_ = congestion_level_;
}

bool VehiclePosition::isCongestion_levelUsed() const
{
    return (isCongestion_levelSet());
}

bool VehiclePosition::isCongestion_levelSet() const
{
    return m_congestion_level_.hasValue();
}

void VehiclePosition::resetCongestion_level()
{
    m_congestion_level_.reset();
}

::gtfsrealtime::OccupancyStatus VehiclePosition::getOccupancy_status() const
{
    return m_occupancy_status_.value();
}

void VehiclePosition::setOccupancy_status(::gtfsrealtime::OccupancyStatus occupancy_status_)
{
    m_occupancy_status_ = occupancy_status_;
}

bool VehiclePosition::isOccupancy_statusUsed() const
{
    return (isOccupancy_statusSet());
}

bool VehiclePosition::isOccupancy_statusSet() const
{
    return m_occupancy_status_.hasValue();
}

void VehiclePosition::resetOccupancy_status()
{
    m_occupancy_status_.reset();
}

void VehiclePosition::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    ::gtfsrealtime::TripDescriptor::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::VehicleDescriptor::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::Position::createPackingContext(contextNode.createChild());
    contextNode.createChild().createContext();
    contextNode.createChild();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
}

void VehiclePosition::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isTripSet())
    {
        m_trip_.value().initPackingContext(contextNode.getChildren().at(0));
    }
    if (isVehicleSet())
    {
        m_vehicle_.value().initPackingContext(contextNode.getChildren().at(1));
    }
    if (isPositionSet())
    {
        m_position_.value().initPackingContext(contextNode.getChildren().at(2));
    }
    if (isCurrent_stop_sequenceSet())
    {
        contextNode.getChildren().at(3).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_current_stop_sequence_.value());
    }
    ::zserio::initPackingContext(contextNode.getChildren().at(5),
            m_current_status_);
    if (isTimestampSet())
    {
        contextNode.getChildren().at(6).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    if (isCongestion_levelSet())
    {
        ::zserio::initPackingContext(contextNode.getChildren().at(7),
                m_congestion_level_.value());
    }
    if (isOccupancy_statusSet())
    {
        ::zserio::initPackingContext(contextNode.getChildren().at(8),
                m_occupancy_status_.value());
    }
}

size_t VehiclePosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition += m_trip_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isPositionSet())
    {
        endBitPosition += m_position_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isCurrent_stop_sequenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_current_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += ::zserio::bitSizeOf(m_current_status_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isCongestion_levelSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_congestion_level_.value());
    }
    endBitPosition += 1;
    if (isOccupancy_statusSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_occupancy_status_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehiclePosition::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition += m_trip_.value().bitSizeOf(
                contextNode.getChildren().at(0), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition += m_vehicle_.value().bitSizeOf(
                contextNode.getChildren().at(1), endBitPosition);
    }
    endBitPosition += 1;
    if (isPositionSet())
    {
        endBitPosition += m_position_.value().bitSizeOf(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isCurrent_stop_sequenceSet())
    {
        endBitPosition += contextNode.getChildren().at(3).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_current_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(5), m_current_status_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(6).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isCongestion_levelSet())
    {
        endBitPosition += ::zserio::bitSizeOf(
                contextNode.getChildren().at(7), m_congestion_level_.value());
    }
    endBitPosition += 1;
    if (isOccupancy_statusSet())
    {
        endBitPosition += ::zserio::bitSizeOf(
                contextNode.getChildren().at(8), m_occupancy_status_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehiclePosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition = m_trip_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isPositionSet())
    {
        endBitPosition = m_position_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isCurrent_stop_sequenceSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_current_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_current_status_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isCongestion_levelSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_congestion_level_.value());
    }
    endBitPosition += 1;
    if (isOccupancy_statusSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_occupancy_status_.value());
    }

    return endBitPosition;
}

size_t VehiclePosition::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition = m_trip_.value().initializeOffsets(
                contextNode.getChildren().at(0), endBitPosition);
    }
    endBitPosition += 1;
    if (isVehicleSet())
    {
        endBitPosition = m_vehicle_.value().initializeOffsets(
                contextNode.getChildren().at(1), endBitPosition);
    }
    endBitPosition += 1;
    if (isPositionSet())
    {
        endBitPosition = m_position_.value().initializeOffsets(
                contextNode.getChildren().at(2), endBitPosition);
    }
    endBitPosition += 1;
    if (isCurrent_stop_sequenceSet())
    {
        endBitPosition += contextNode.getChildren().at(3).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_current_stop_sequence_.value());
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(5), endBitPosition, m_current_status_);
    endBitPosition += 1;
    if (isTimestampSet())
    {
        endBitPosition += contextNode.getChildren().at(6).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_timestamp_.value());
    }
    endBitPosition += 1;
    if (isCongestion_levelSet())
    {
        endBitPosition = ::zserio::initializeOffsets(
                contextNode.getChildren().at(7), endBitPosition, m_congestion_level_.value());
    }
    endBitPosition += 1;
    if (isOccupancy_statusSet())
    {
        endBitPosition = ::zserio::initializeOffsets(
                contextNode.getChildren().at(8), endBitPosition, m_occupancy_status_.value());
    }

    return endBitPosition;
}

bool VehiclePosition::operator==(const VehiclePosition& other) const
{
    if (this != &other)
    {
        return
                ((!isTripUsed()) ? !other.isTripUsed() : (m_trip_ == other.m_trip_)) &&
                ((!isVehicleUsed()) ? !other.isVehicleUsed() : (m_vehicle_ == other.m_vehicle_)) &&
                ((!isPositionUsed()) ? !other.isPositionUsed() : (m_position_ == other.m_position_)) &&
                ((!isCurrent_stop_sequenceUsed()) ? !other.isCurrent_stop_sequenceUsed() : (m_current_stop_sequence_ == other.m_current_stop_sequence_)) &&
                ((!isStop_idUsed()) ? !other.isStop_idUsed() : (m_stop_id_ == other.m_stop_id_)) &&
                (m_current_status_ == other.m_current_status_) &&
                ((!isTimestampUsed()) ? !other.isTimestampUsed() : (m_timestamp_ == other.m_timestamp_)) &&
                ((!isCongestion_levelUsed()) ? !other.isCongestion_levelUsed() : (m_congestion_level_ == other.m_congestion_level_)) &&
                ((!isOccupancy_statusUsed()) ? !other.isOccupancy_statusUsed() : (m_occupancy_status_ == other.m_occupancy_status_));
    }

    return true;
}

uint32_t VehiclePosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isTripUsed())
        result = ::zserio::calcHashCode(result, m_trip_);
    if (isVehicleUsed())
        result = ::zserio::calcHashCode(result, m_vehicle_);
    if (isPositionUsed())
        result = ::zserio::calcHashCode(result, m_position_);
    if (isCurrent_stop_sequenceUsed())
        result = ::zserio::calcHashCode(result, m_current_stop_sequence_);
    if (isStop_idUsed())
        result = ::zserio::calcHashCode(result, m_stop_id_);
    result = ::zserio::calcHashCode(result, m_current_status_);
    if (isTimestampUsed())
        result = ::zserio::calcHashCode(result, m_timestamp_);
    if (isCongestion_levelUsed())
        result = ::zserio::calcHashCode(result, m_congestion_level_);
    if (isOccupancy_statusUsed())
        result = ::zserio::calcHashCode(result, m_occupancy_status_);

    return result;
}

void VehiclePosition::write(::zserio::BitStreamWriter& out) const
{
    if (isTripSet())
    {
        out.writeBool(true);
        m_trip_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isPositionSet())
    {
        out.writeBool(true);
        m_position_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isCurrent_stop_sequenceSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_current_stop_sequence_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    ::zserio::write(out, m_current_status_);
    if (isTimestampSet())
    {
        out.writeBool(true);
        out.writeVarUInt64(m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCongestion_levelSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_congestion_level_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isOccupancy_statusSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_occupancy_status_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void VehiclePosition::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isTripSet())
    {
        out.writeBool(true);
        m_trip_.value().write(contextNode.getChildren().at(0), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isVehicleSet())
    {
        out.writeBool(true);
        m_vehicle_.value().write(contextNode.getChildren().at(1), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isPositionSet())
    {
        out.writeBool(true);
        m_position_.value().write(contextNode.getChildren().at(2), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isCurrent_stop_sequenceSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(3).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), out, m_current_stop_sequence_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    ::zserio::write(contextNode.getChildren().at(5), out, m_current_status_);
    if (isTimestampSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(6).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), out, m_timestamp_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCongestion_levelSet())
    {
        out.writeBool(true);
        ::zserio::write(contextNode.getChildren().at(7), out, m_congestion_level_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isOccupancy_statusSet())
    {
        out.writeBool(true);
        ::zserio::write(contextNode.getChildren().at(8), out, m_occupancy_status_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor> VehiclePosition::readTrip(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::gtfsrealtime::TripDescriptor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor> VehiclePosition::readTrip(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::gtfsrealtime::TripDescriptor(contextNode.getChildren().at(0), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor> VehiclePosition::readVehicle(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::gtfsrealtime::VehicleDescriptor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor> VehiclePosition::readVehicle(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::gtfsrealtime::VehicleDescriptor(contextNode.getChildren().at(1), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::VehicleDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::Position> VehiclePosition::readPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Position>(::gtfsrealtime::Position(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Position>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::Position> VehiclePosition::readPosition(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Position>(::gtfsrealtime::Position(contextNode.getChildren().at(2), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::Position>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> VehiclePosition::readCurrent_stop_sequence(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> VehiclePosition::readCurrent_stop_sequence(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(contextNode.getChildren().at(3).getContext().read(::zserio::VarIntNNArrayTraits<uint32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> VehiclePosition::readStop_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::gtfsrealtime::VehicleStopStatus VehiclePosition::readCurrent_status(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::VehicleStopStatus>(in);
}

::gtfsrealtime::VehicleStopStatus VehiclePosition::readCurrent_status(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::VehicleStopStatus>(contextNode.getChildren().at(5), in);
}

::zserio::InplaceOptionalHolder<uint64_t> VehiclePosition::readTimestamp(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> VehiclePosition::readTimestamp(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(contextNode.getChildren().at(6).getContext().read(::zserio::VarIntNNArrayTraits<uint64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel> VehiclePosition::readCongestion_level(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel>(::zserio::read<::gtfsrealtime::CongestionLevel>(in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel> VehiclePosition::readCongestion_level(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel>(::zserio::read<::gtfsrealtime::CongestionLevel>(contextNode.getChildren().at(7), in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::CongestionLevel>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus> VehiclePosition::readOccupancy_status(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus>(::zserio::read<::gtfsrealtime::OccupancyStatus>(in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus> VehiclePosition::readOccupancy_status(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus>(::zserio::read<::gtfsrealtime::OccupancyStatus>(contextNode.getChildren().at(8), in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::OccupancyStatus>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <functional>
#include <zserio/ArrayTraits.h>

#include <gtfsrealtime/Alert.h>
#include <gtfsrealtime/Cause.h>
#include <gtfsrealtime/Effect.h>

namespace gtfsrealtime
{

Alert::ZserioElementFactory_active_period::ZserioElementFactory_active_period(Alert& owner) :
        m_ownerRef(owner)
{}

void Alert::ZserioElementFactory_active_period::create(::zserio::vector<::gtfsrealtime::TimeRange>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, array.get_allocator());
}

void Alert::ZserioElementFactory_active_period::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::gtfsrealtime::TimeRange>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, array.get_allocator());
}

Alert::ZserioElementFactory_informed_entity::ZserioElementFactory_informed_entity(Alert& owner) :
        m_ownerRef(owner)
{}

void Alert::ZserioElementFactory_informed_entity::create(::zserio::vector<::gtfsrealtime::EntitySelector>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, array.get_allocator());
}

void Alert::ZserioElementFactory_informed_entity::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::gtfsrealtime::EntitySelector>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, array.get_allocator());
}

Alert::Alert(const allocator_type& allocator) noexcept :
        m_active_period_(::zserio::ObjectArrayTraits<::gtfsrealtime::TimeRange, ZserioElementFactory_active_period>(), allocator),
        m_informed_entity_(::zserio::ObjectArrayTraits<::gtfsrealtime::EntitySelector, ZserioElementFactory_informed_entity>(), allocator),
        m_cause_(static_cast<::gtfsrealtime::Cause>(::gtfsrealtime::Cause::UNKNOWN_CAUSE)),
        m_effect_(static_cast<::gtfsrealtime::Effect>(::gtfsrealtime::Effect::UNKNOWN_EFFECT)),
        m_url_(::zserio::NullOpt),
        m_header_text_(::zserio::NullOpt),
        m_description_text_(::zserio::NullOpt)
{
}

Alert::Alert(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_active_period_(readActive_period(in, allocator)),
        m_informed_entity_(readInformed_entity(in, allocator)),
        m_cause_(readCause(in)),
        m_effect_(readEffect(in)),
        m_url_(readUrl(in, allocator)),
        m_header_text_(readHeader_text(in, allocator)),
        m_description_text_(readDescription_text(in, allocator))
{
}

Alert::Alert(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_active_period_(readActive_period(contextNode, in, allocator)),
        m_informed_entity_(readInformed_entity(contextNode, in, allocator)),
        m_cause_(readCause(contextNode, in)),
        m_effect_(readEffect(contextNode, in)),
        m_url_(readUrl(contextNode, in, allocator)),
        m_header_text_(readHeader_text(contextNode, in, allocator)),
        m_description_text_(readDescription_text(contextNode, in, allocator))
{
}

Alert::Alert(::zserio::PropagateAllocatorT,
        const Alert& other, const allocator_type& allocator) :
        m_active_period_(::zserio::allocatorPropagatingCopy(other.m_active_period_, allocator)),
        m_informed_entity_(::zserio::allocatorPropagatingCopy(other.m_informed_entity_, allocator)),
        m_cause_(::zserio::allocatorPropagatingCopy(other.m_cause_, allocator)),
        m_effect_(::zserio::allocatorPropagatingCopy(other.m_effect_, allocator)),
        m_url_(::zserio::allocatorPropagatingCopy(other.m_url_, allocator)),
        m_header_text_(::zserio::allocatorPropagatingCopy(other.m_header_text_, allocator)),
        m_description_text_(::zserio::allocatorPropagatingCopy(other.m_description_text_, allocator))
{
}

::zserio::vector<::gtfsrealtime::TimeRange>& Alert::getActive_period()
{
    return m_active_period_.getRawArray();
}

const ::zserio::vector<::gtfsrealtime::TimeRange>& Alert::getActive_period() const
{
    return m_active_period_.getRawArray();
}

void Alert::setActive_period(const ::zserio::vector<::gtfsrealtime::TimeRange>& active_period_)
{
    m_active_period_ = ZserioArrayType_active_period(active_period_, ::zserio::ObjectArrayTraits<::gtfsrealtime::TimeRange, ZserioElementFactory_active_period>());
}

void Alert::setActive_period(::zserio::vector<::gtfsrealtime::TimeRange>&& active_period_)
{
    m_active_period_ = ZserioArrayType_active_period(std::move(active_period_), ::zserio::ObjectArrayTraits<::gtfsrealtime::TimeRange, ZserioElementFactory_active_period>());
}

::zserio::vector<::gtfsrealtime::EntitySelector>& Alert::getInformed_entity()
{
    return m_informed_entity_.getRawArray();
}

const ::zserio::vector<::gtfsrealtime::EntitySelector>& Alert::getInformed_entity() const
{
    return m_informed_entity_.getRawArray();
}

void Alert::setInformed_entity(const ::zserio::vector<::gtfsrealtime::EntitySelector>& informed_entity_)
{
    m_informed_entity_ = ZserioArrayType_informed_entity(informed_entity_, ::zserio::ObjectArrayTraits<::gtfsrealtime::EntitySelector, ZserioElementFactory_informed_entity>());
}

void Alert::setInformed_entity(::zserio::vector<::gtfsrealtime::EntitySelector>&& informed_entity_)
{
    m_informed_entity_ = ZserioArrayType_informed_entity(std::move(informed_entity_), ::zserio::ObjectArrayTraits<::gtfsrealtime::EntitySelector, ZserioElementFactory_informed_entity>());
}

::gtfsrealtime::Cause Alert::getCause() const
{
    return m_cause_;
}

void Alert::setCause(::gtfsrealtime::Cause cause_)
{
    m_cause_ = cause_;
}

::gtfsrealtime::Effect Alert::getEffect() const
{
    return m_effect_;
}

void Alert::setEffect(::gtfsrealtime::Effect effect_)
{
    m_effect_ = effect_;
}

::gtfsrealtime::TranslatedString& Alert::getUrl()
{
    return m_url_.value();
}

const ::gtfsrealtime::TranslatedString& Alert::getUrl() const
{
    return m_url_.value();
}

void Alert::setUrl(const ::gtfsrealtime::TranslatedString& url_)
{
    m_url_ = url_;
}

void Alert::setUrl(::gtfsrealtime::TranslatedString&& url_)
{
    m_url_ = ::std::move(url_);
}

bool Alert::isUrlUsed() const
{
    return (isUrlSet());
}

bool Alert::isUrlSet() const
{
    return m_url_.hasValue();
}

void Alert::resetUrl()
{
    m_url_.reset();
}

::gtfsrealtime::TranslatedString& Alert::getHeader_text()
{
    return m_header_text_.value();
}

const ::gtfsrealtime::TranslatedString& Alert::getHeader_text() const
{
    return m_header_text_.value();
}

void Alert::setHeader_text(const ::gtfsrealtime::TranslatedString& header_text_)
{
    m_header_text_ = header_text_;
}

void Alert::setHeader_text(::gtfsrealtime::TranslatedString&& header_text_)
{
    m_header_text_ = ::std::move(header_text_);
}

bool Alert::isHeader_textUsed() const
{
    return (isHeader_textSet());
}

bool Alert::isHeader_textSet() const
{
    return m_header_text_.hasValue();
}

void Alert::resetHeader_text()
{
    m_header_text_.reset();
}

::gtfsrealtime::TranslatedString& Alert::getDescription_text()
{
    return m_description_text_.value();
}

const ::gtfsrealtime::TranslatedString& Alert::getDescription_text() const
{
    return m_description_text_.value();
}

void Alert::setDescription_text(const ::gtfsrealtime::TranslatedString& description_text_)
{
    m_description_text_ = description_text_;
}

void Alert::setDescription_text(::gtfsrealtime::TranslatedString&& description_text_)
{
    m_description_text_ = ::std::move(description_text_);
}

bool Alert::isDescription_textUsed() const
{
    return (isDescription_textSet());
}

bool Alert::isDescription_textSet() const
{
    return m_description_text_.hasValue();
}

void Alert::resetDescription_text()
{
    m_description_text_.reset();
}

void Alert::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
    ::gtfsrealtime::TranslatedString::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::TranslatedString::createPackingContext(contextNode.createChild());
    ::gtfsrealtime::TranslatedString::createPackingContext(contextNode.createChild());
}

void Alert::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    ::zserio::initPackingContext(contextNode.getChildren().at(2),
            m_cause_);
    ::zserio::initPackingContext(contextNode.getChildren().at(3),
            m_effect_);
    if (isUrlSet())
    {
        m_url_.value().initPackingContext(contextNode.getChildren().at(4));
    }
    if (isHeader_textSet())
    {
        m_header_text_.value().initPackingContext(contextNode.getChildren().at(5));
    }
    if (isDescription_textSet())
    {
        m_description_text_.value().initPackingContext(contextNode.getChildren().at(6));
    }
}

size_t Alert::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_active_period_.bitSizeOf(endBitPosition);
    endBitPosition += m_informed_entity_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_cause_);
    endBitPosition += ::zserio::bitSizeOf(m_effect_);
    endBitPosition += 1;
    if (isUrlSet())
    {
        endBitPosition += m_url_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isHeader_textSet())
    {
        endBitPosition += m_header_text_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isDescription_textSet())
    {
        endBitPosition += m_description_text_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Alert::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_active_period_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_informed_entity_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(2), m_cause_);
    endBitPosition += ::zserio::bitSizeOf(
            contextNode.getChildren().at(3), m_effect_);
    endBitPosition += 1;
    if (isUrlSet())
    {
        endBitPosition += m_url_.value().bitSizeOf(
                contextNode.getChildren().at(4), endBitPosition);
    }
    endBitPosition += 1;
    if (isHeader_textSet())
    {
        endBitPosition += m_header_text_.value().bitSizeOf(
                contextNode.getChildren().at(5), endBitPosition);
    }
    endBitPosition += 1;
    if (isDescription_textSet())
    {
        endBitPosition += m_description_text_.value().bitSizeOf(
                contextNode.getChildren().at(6), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Alert::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_active_period_.initializeOffsets(
            endBitPosition);
    endBitPosition = m_informed_entity_.initializeOffsets(
            endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_cause_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_effect_);
    endBitPosition += 1;
    if (isUrlSet())
    {
        endBitPosition = m_url_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isHeader_textSet())
    {
        endBitPosition = m_header_text_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isDescription_textSet())
    {
        endBitPosition = m_description_text_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t Alert::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_active_period_.initializeOffsetsPacked(
            endBitPosition);
    endBitPosition = m_informed_entity_.initializeOffsetsPacked(
            endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(2), endBitPosition, m_cause_);
    endBitPosition = ::zserio::initializeOffsets(
            contextNode.getChildren().at(3), endBitPosition, m_effect_);
    endBitPosition += 1;
    if (isUrlSet())
    {
        endBitPosition = m_url_.value().initializeOffsets(
                contextNode.getChildren().at(4), endBitPosition);
    }
    endBitPosition += 1;
    if (isHeader_textSet())
    {
        endBitPosition = m_header_text_.value().initializeOffsets(
                contextNode.getChildren().at(5), endBitPosition);
    }
    endBitPosition += 1;
    if (isDescription_textSet())
    {
        endBitPosition = m_description_text_.value().initializeOffsets(
                contextNode.getChildren().at(6), endBitPosition);
    }

    return endBitPosition;
}

bool Alert::operator==(const Alert& other) const
{
    if (this != &other)
    {
        return
                (m_active_period_ == other.m_active_period_) &&
                (m_informed_entity_ == other.m_informed_entity_) &&
                (m_cause_ == other.m_cause_) &&
                (m_effect_ == other.m_effect_) &&
                ((!isUrlUsed()) ? !other.isUrlUsed() : (m_url_ == other.m_url_)) &&
                ((!isHeader_textUsed()) ? !other.isHeader_textUsed() : (m_header_text_ == other.m_header_text_)) &&
                ((!isDescription_textUsed()) ? !other.isDescription_textUsed() : (m_description_text_ == other.m_description_text_));
    }

    return true;
}

uint32_t Alert::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_active_period_);
    result = ::zserio::calcHashCode(result, m_informed_entity_);
    result = ::zserio::calcHashCode(result, m_cause_);
    result = ::zserio::calcHashCode(result, m_effect_);
    if (isUrlUsed())
        result = ::zserio::calcHashCode(result, m_url_);
    if (isHeader_textUsed())
        result = ::zserio::calcHashCode(result, m_header_text_);
    if (isDescription_textUsed())
        result = ::zserio::calcHashCode(result, m_description_text_);

    return result;
}

void Alert::write(::zserio::BitStreamWriter& out) const
{
    m_active_period_.write(out);
    m_informed_entity_.write(out);
    ::zserio::write(out, m_cause_);
    ::zserio::write(out, m_effect_);
    if (isUrlSet())
    {
        out.writeBool(true);
        m_url_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeader_textSet())
    {
        out.writeBool(true);
        m_header_text_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDescription_textSet())
    {
        out.writeBool(true);
        m_description_text_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void Alert::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    m_active_period_.writePacked(out);
    m_informed_entity_.writePacked(out);
    ::zserio::write(contextNode.getChildren().at(2), out, m_cause_);
    ::zserio::write(contextNode.getChildren().at(3), out, m_effect_);
    if (isUrlSet())
    {
        out.writeBool(true);
        m_url_.value().write(contextNode.getChildren().at(4), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeader_textSet())
    {
        out.writeBool(true);
        m_header_text_.value().write(contextNode.getChildren().at(5), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isDescription_textSet())
    {
        out.writeBool(true);
        m_description_text_.value().write(contextNode.getChildren().at(6), out);
    }
    else
    {
        out.writeBool(false);
    }
}

Alert::ZserioArrayType_active_period Alert::readActive_period(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_active_period readField(::zserio::ObjectArrayTraits<::gtfsrealtime::TimeRange, ZserioElementFactory_active_period>(), allocator);
    readField.read(in, ZserioElementFactory_active_period(*this));

    return readField;
}

Alert::ZserioArrayType_active_period Alert::readActive_period(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_active_period readField(::zserio::ObjectArrayTraits<::gtfsrealtime::TimeRange, ZserioElementFactory_active_period>(), allocator);
    readField.readPacked(in, ZserioElementFactory_active_period(*this));

    return readField;
}

Alert::ZserioArrayType_informed_entity Alert::readInformed_entity(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_informed_entity readField(::zserio::ObjectArrayTraits<::gtfsrealtime::EntitySelector, ZserioElementFactory_informed_entity>(), allocator);
    readField.read(in, ZserioElementFactory_informed_entity(*this));

    return readField;
}

Alert::ZserioArrayType_informed_entity Alert::readInformed_entity(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_informed_entity readField(::zserio::ObjectArrayTraits<::gtfsrealtime::EntitySelector, ZserioElementFactory_informed_entity>(), allocator);
    readField.readPacked(in, ZserioElementFactory_informed_entity(*this));

    return readField;
}

::gtfsrealtime::Cause Alert::readCause(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Cause>(in);
}

::gtfsrealtime::Cause Alert::readCause(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Cause>(contextNode.getChildren().at(2), in);
}

::gtfsrealtime::Effect Alert::readEffect(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Effect>(in);
}

::gtfsrealtime::Effect Alert::readEffect(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::gtfsrealtime::Effect>(contextNode.getChildren().at(3), in);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readUrl(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readUrl(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(contextNode.getChildren().at(4), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readHeader_text(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readHeader_text(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(contextNode.getChildren().at(5), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readDescription_text(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString> Alert::readDescription_text(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::gtfsrealtime::TranslatedString(contextNode.getChildren().at(6), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TranslatedString>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/TimeRange.h>

namespace gtfsrealtime
{

TimeRange::TimeRange(const allocator_type&) noexcept :
        m_start_(::zserio::NullOpt),
        m_end_(::zserio::NullOpt)
{
}

TimeRange::TimeRange(::zserio::BitStreamReader& in, const allocator_type&) :
        m_start_(readStart(in)),
        m_end_(readEnd(in))
{
}

TimeRange::TimeRange(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_start_(readStart(contextNode, in)),
        m_end_(readEnd(contextNode, in))
{
}

TimeRange::TimeRange(::zserio::PropagateAllocatorT,
        const TimeRange& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
}

uint64_t TimeRange::getStart() const
{
    return m_start_.value();
}

void TimeRange::setStart(uint64_t start_)
{
    m_start_ = start_;
}

bool TimeRange::isStartUsed() const
{
    return (isStartSet());
}

bool TimeRange::isStartSet() const
{
    return m_start_.hasValue();
}

void TimeRange::resetStart()
{
    m_start_.reset();
}

uint64_t TimeRange::getEnd() const
{
    return m_end_.value();
}

void TimeRange::setEnd(uint64_t end_)
{
    m_end_ = end_;
}

bool TimeRange::isEndUsed() const
{
    return (isEndSet());
}

bool TimeRange::isEndSet() const
{
    return m_end_.hasValue();
}

void TimeRange::resetEnd()
{
    m_end_.reset();
}

void TimeRange::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild().createContext();
    contextNode.createChild().createContext();
}

void TimeRange::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isStartSet())
    {
        contextNode.getChildren().at(0).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_start_.value());
    }
    if (isEndSet())
    {
        contextNode.getChildren().at(1).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_end_.value());
    }
}

size_t TimeRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStartSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_start_.value());
    }
    endBitPosition += 1;
    if (isEndSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_end_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TimeRange::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStartSet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_start_.value());
    }
    endBitPosition += 1;
    if (isEndSet())
    {
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_end_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TimeRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStartSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_start_.value());
    }
    endBitPosition += 1;
    if (isEndSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_end_.value());
    }

    return endBitPosition;
}

size_t TimeRange::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isStartSet())
    {
        endBitPosition += contextNode.getChildren().at(0).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_start_.value());
    }
    endBitPosition += 1;
    if (isEndSet())
    {
        endBitPosition += contextNode.getChildren().at(1).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), m_end_.value());
    }

    return endBitPosition;
}

bool TimeRange::operator==(const TimeRange& other) const
{
    if (this != &other)
    {
        return
                ((!isStartUsed()) ? !other.isStartUsed() : (m_start_ == other.m_start_)) &&
                ((!isEndUsed()) ? !other.isEndUsed() : (m_end_ == other.m_end_));
    }

    return true;
}

uint32_t TimeRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isStartUsed())
        result = ::zserio::calcHashCode(result, m_start_);
    if (isEndUsed())
        result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void TimeRange::write(::zserio::BitStreamWriter& out) const
{
    if (isStartSet())
    {
        out.writeBool(true);
        out.writeVarUInt64(m_start_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isEndSet())
    {
        out.writeBool(true);
        out.writeVarUInt64(m_end_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void TimeRange::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isStartSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(0).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), out, m_start_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isEndSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(1).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint64_t>(), out, m_end_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<uint64_t> TimeRange::readStart(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> TimeRange::readStart(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(contextNode.getChildren().at(0).getContext().read(::zserio::VarIntNNArrayTraits<uint64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> TimeRange::readEnd(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> TimeRange::readEnd(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(contextNode.getChildren().at(1).getContext().read(::zserio::VarIntNNArrayTraits<uint64_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/Position.h>

namespace gtfsrealtime
{

Position::Position(const allocator_type&) noexcept :
        m_latitude_(float()),
        m_longitude_(float()),
        m_bearing_(::zserio::NullOpt),
        m_odometer_(::zserio::NullOpt),
        m_speed_(::zserio::NullOpt)
{
}

Position::Position(::zserio::BitStreamReader& in, const allocator_type&) :
        m_latitude_(readLatitude(in)),
        m_longitude_(readLongitude(in)),
        m_bearing_(readBearing(in)),
        m_odometer_(readOdometer(in)),
        m_speed_(readSpeed(in))
{
}

Position::Position(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_latitude_(readLatitude(in)),
        m_longitude_(readLongitude(in)),
        m_bearing_(readBearing(in)),
        m_odometer_(readOdometer(in)),
        m_speed_(readSpeed(in))
{
}

Position::Position(::zserio::PropagateAllocatorT,
        const Position& other, const allocator_type& allocator) :
        m_latitude_(::zserio::allocatorPropagatingCopy(other.m_latitude_, allocator)),
        m_longitude_(::zserio::allocatorPropagatingCopy(other.m_longitude_, allocator)),
        m_bearing_(::zserio::allocatorPropagatingCopy(other.m_bearing_, allocator)),
        m_odometer_(::zserio::allocatorPropagatingCopy(other.m_odometer_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator))
{
}

float Position::getLatitude() const
{
    return m_latitude_;
}

void Position::setLatitude(float latitude_)
{
    m_latitude_ = latitude_;
}

float Position::getLongitude() const
{
    return m_longitude_;
}

void Position::setLongitude(float longitude_)
{
    m_longitude_ = longitude_;
}

float Position::getBearing() const
{
    return m_bearing_.value();
}

void Position::setBearing(float bearing_)
{
    m_bearing_ = bearing_;
}

bool Position::isBearingUsed() const
{
    return (isBearingSet());
}

bool Position::isBearingSet() const
{
    return m_bearing_.hasValue();
}

void Position::resetBearing()
{
    m_bearing_.reset();
}

double Position::getOdometer() const
{
    return m_odometer_.value();
}

void Position::setOdometer(double odometer_)
{
    m_odometer_ = odometer_;
}

bool Position::isOdometerUsed() const
{
    return (isOdometerSet());
}

bool Position::isOdometerSet() const
{
    return m_odometer_.hasValue();
}

void Position::resetOdometer()
{
    m_odometer_.reset();
}

float Position::getSpeed() const
{
    return m_speed_.value();
}

void Position::setSpeed(float speed_)
{
    m_speed_ = speed_;
}

bool Position::isSpeedUsed() const
{
    return (isSpeedSet());
}

bool Position::isSpeedSet() const
{
    return m_speed_.hasValue();
}

void Position::resetSpeed()
{
    m_speed_.reset();
}

void Position::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
}

void Position::initPackingContext(::zserio::PackingContextNode&) const
{
}

size_t Position::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isBearingSet())
    {
        endBitPosition += UINT8_C(32);
    }
    endBitPosition += 1;
    if (isOdometerSet())
    {
        endBitPosition += UINT8_C(64);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition - bitPosition;
}

size_t Position::bitSizeOf(::zserio::PackingContextNode&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isBearingSet())
    {
        endBitPosition += UINT8_C(32);
    }
    endBitPosition += 1;
    if (isOdometerSet())
    {
        endBitPosition += UINT8_C(64);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition - bitPosition;
}

size_t Position::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isBearingSet())
    {
        endBitPosition += UINT8_C(32);
    }
    endBitPosition += 1;
    if (isOdometerSet())
    {
        endBitPosition += UINT8_C(64);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition;
}

size_t Position::initializeOffsets(::zserio::PackingContextNode&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isBearingSet())
    {
        endBitPosition += UINT8_C(32);
    }
    endBitPosition += 1;
    if (isOdometerSet())
    {
        endBitPosition += UINT8_C(64);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(32);
    }

    return endBitPosition;
}

bool Position::operator==(const Position& other) const
{
    if (this != &other)
    {
        return
                (m_latitude_ == other.m_latitude_) &&
                (m_longitude_ == other.m_longitude_) &&
                ((!isBearingUsed()) ? !other.isBearingUsed() : (m_bearing_ == other.m_bearing_)) &&
                ((!isOdometerUsed()) ? !other.isOdometerUsed() : (m_odometer_ == other.m_odometer_)) &&
                ((!isSpeedUsed()) ? !other.isSpeedUsed() : (m_speed_ == other.m_speed_));
    }

    return true;
}

uint32_t Position::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_latitude_);
    result = ::zserio::calcHashCode(result, m_longitude_);
    if (isBearingUsed())
        result = ::zserio::calcHashCode(result, m_bearing_);
    if (isOdometerUsed())
        result = ::zserio::calcHashCode(result, m_odometer_);
    if (isSpeedUsed())
        result = ::zserio::calcHashCode(result, m_speed_);

    return result;
}

void Position::write(::zserio::BitStreamWriter& out) const
{
    out.writeFloat32(m_latitude_);
    out.writeFloat32(m_longitude_);
    if (isBearingSet())
    {
        out.writeBool(true);
        out.writeFloat32(m_bearing_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isOdometerSet())
    {
        out.writeBool(true);
        out.writeFloat64(m_odometer_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        out.writeFloat32(m_speed_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void Position::write(::zserio::PackingContextNode&, ::zserio::BitStreamWriter& out) const
{
    out.writeFloat32(m_latitude_);
    out.writeFloat32(m_longitude_);
    if (isBearingSet())
    {
        out.writeBool(true);
        out.writeFloat32(m_bearing_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isOdometerSet())
    {
        out.writeBool(true);
        out.writeFloat64(m_odometer_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        out.writeFloat32(m_speed_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

float Position::readLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat32());
}

float Position::readLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat32());
}

::zserio::InplaceOptionalHolder<float> Position::readBearing(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<float>(static_cast<float>(in.readFloat32()));
    }

    return ::zserio::InplaceOptionalHolder<float>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<double> Position::readOdometer(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<double>(static_cast<double>(in.readFloat64()));
    }

    return ::zserio::InplaceOptionalHolder<double>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<float> Position::readSpeed(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<float>(static_cast<float>(in.readFloat32()));
    }

    return ::zserio::InplaceOptionalHolder<float>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/TripDescriptor.h>

namespace gtfsrealtime
{

TripDescriptor::TripDescriptor(const allocator_type&) noexcept :
        m_trip_id_(::zserio::NullOpt),
        m_route_id_(::zserio::NullOpt),
        m_direction_id_(::zserio::NullOpt),
        m_start_time_(::zserio::NullOpt),
        m_start_date_(::zserio::NullOpt),
        m_schedule_relationship_(::zserio::NullOpt)
{
}

TripDescriptor::TripDescriptor(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_id_(readTrip_id(in, allocator)),
        m_route_id_(readRoute_id(in, allocator)),
        m_direction_id_(readDirection_id(in)),
        m_start_time_(readStart_time(in, allocator)),
        m_start_date_(readStart_date(in, allocator)),
        m_schedule_relationship_(readSchedule_relationship(in))
{
}

TripDescriptor::TripDescriptor(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_trip_id_(readTrip_id(in, allocator)),
        m_route_id_(readRoute_id(in, allocator)),
        m_direction_id_(readDirection_id(contextNode, in)),
        m_start_time_(readStart_time(in, allocator)),
        m_start_date_(readStart_date(in, allocator)),
        m_schedule_relationship_(readSchedule_relationship(contextNode, in))
{
}

TripDescriptor::TripDescriptor(::zserio::PropagateAllocatorT,
        const TripDescriptor& other, const allocator_type& allocator) :
        m_trip_id_(::zserio::allocatorPropagatingCopy(other.m_trip_id_, allocator)),
        m_route_id_(::zserio::allocatorPropagatingCopy(other.m_route_id_, allocator)),
        m_direction_id_(::zserio::allocatorPropagatingCopy(other.m_direction_id_, allocator)),
        m_start_time_(::zserio::allocatorPropagatingCopy(other.m_start_time_, allocator)),
        m_start_date_(::zserio::allocatorPropagatingCopy(other.m_start_date_, allocator)),
        m_schedule_relationship_(::zserio::allocatorPropagatingCopy(other.m_schedule_relationship_, allocator))
{
}

::zserio::string<>& TripDescriptor::getTrip_id()
{
    return m_trip_id_.value();
}

const ::zserio::string<>& TripDescriptor::getTrip_id() const
{
    return m_trip_id_.value();
}

void TripDescriptor::setTrip_id(const ::zserio::string<>& trip_id_)
{
    m_trip_id_ = trip_id_;
}

void TripDescriptor::setTrip_id(::zserio::string<>&& trip_id_)
{
    m_trip_id_ = ::std::move(trip_id_);
}

bool TripDescriptor::isTrip_idUsed() const
{
    return (isTrip_idSet());
}

bool TripDescriptor::isTrip_idSet() const
{
    return m_trip_id_.hasValue();
}

void TripDescriptor::resetTrip_id()
{
    m_trip_id_.reset();
}

::zserio::string<>& TripDescriptor::getRoute_id()
{
    return m_route_id_.value();
}

const ::zserio::string<>& TripDescriptor::getRoute_id() const
{
    return m_route_id_.value();
}

void TripDescriptor::setRoute_id(const ::zserio::string<>& route_id_)
{
    m_route_id_ = route_id_;
}

void TripDescriptor::setRoute_id(::zserio::string<>&& route_id_)
{
    m_route_id_ = ::std::move(route_id_);
}

bool TripDescriptor::isRoute_idUsed() const
{
    return (isRoute_idSet());
}

bool TripDescriptor::isRoute_idSet() const
{
    return m_route_id_.hasValue();
}

void TripDescriptor::resetRoute_id()
{
    m_route_id_.reset();
}

uint32_t TripDescriptor::getDirection_id() const
{
    return m_direction_id_.value();
}

void TripDescriptor::setDirection_id(uint32_t direction_id_)
{
    m_direction_id_ = direction_id_;
}

bool TripDescriptor::isDirection_idUsed() const
{
    return (isDirection_idSet());
}

bool TripDescriptor::isDirection_idSet() const
{
    return m_direction_id_.hasValue();
}

void TripDescriptor::resetDirection_id()
{
    m_direction_id_.reset();
}

::zserio::string<>& TripDescriptor::getStart_time()
{
    return m_start_time_.value();
}

const ::zserio::string<>& TripDescriptor::getStart_time() const
{
    return m_start_time_.value();
}

void TripDescriptor::setStart_time(const ::zserio::string<>& start_time_)
{
    m_start_time_ = start_time_;
}

void TripDescriptor::setStart_time(::zserio::string<>&& start_time_)
{
    m_start_time_ = ::std::move(start_time_);
}

bool TripDescriptor::isStart_timeUsed() const
{
    return (isStart_timeSet());
}

bool TripDescriptor::isStart_timeSet() const
{
    return m_start_time_.hasValue();
}

void TripDescriptor::resetStart_time()
{
    m_start_time_.reset();
}

::zserio::string<>& TripDescriptor::getStart_date()
{
    return m_start_date_.value();
}

const ::zserio::string<>& TripDescriptor::getStart_date() const
{
    return m_start_date_.value();
}

void TripDescriptor::setStart_date(const ::zserio::string<>& start_date_)
{
    m_start_date_ = start_date_;
}

void TripDescriptor::setStart_date(::zserio::string<>&& start_date_)
{
    m_start_date_ = ::std::move(start_date_);
}

bool TripDescriptor::isStart_dateUsed() const
{
    return (isStart_dateSet());
}

bool TripDescriptor::isStart_dateSet() const
{
    return m_start_date_.hasValue();
}

void TripDescriptor::resetStart_date()
{
    m_start_date_.reset();
}

::gtfsrealtime::ScheduleRelationship TripDescriptor::getSchedule_relationship() const
{
    return m_schedule_relationship_.value();
}

void TripDescriptor::setSchedule_relationship(::gtfsrealtime::ScheduleRelationship schedule_relationship_)
{
    m_schedule_relationship_ = schedule_relationship_;
}

bool TripDescriptor::isSchedule_relationshipUsed() const
{
    return (isSchedule_relationshipSet());
}

bool TripDescriptor::isSchedule_relationshipSet() const
{
    return m_schedule_relationship_.hasValue();
}

void TripDescriptor::resetSchedule_relationship()
{
    m_schedule_relationship_.reset();
}

void TripDescriptor::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild().createContext();
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild().createContext();
}

void TripDescriptor::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isDirection_idSet())
    {
        contextNode.getChildren().at(2).getContext().init(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_direction_id_.value());
    }
    if (isSchedule_relationshipSet())
    {
        ::zserio::initPackingContext(contextNode.getChildren().at(5),
                m_schedule_relationship_.value());
    }
}

size_t TripDescriptor::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTrip_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_trip_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isDirection_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_direction_id_.value());
    }
    endBitPosition += 1;
    if (isStart_timeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_time_.value());
    }
    endBitPosition += 1;
    if (isStart_dateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_date_.value());
    }
    endBitPosition += 1;
    if (isSchedule_relationshipSet())
    {
        endBitPosition += ::zserio::bitSizeOf(m_schedule_relationship_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TripDescriptor::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTrip_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_trip_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isDirection_idSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_direction_id_.value());
    }
    endBitPosition += 1;
    if (isStart_timeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_time_.value());
    }
    endBitPosition += 1;
    if (isStart_dateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_date_.value());
    }
    endBitPosition += 1;
    if (isSchedule_relationshipSet())
    {
        endBitPosition += ::zserio::bitSizeOf(
                contextNode.getChildren().at(5), m_schedule_relationship_.value());
    }

    return endBitPosition - bitPosition;
}

size_t TripDescriptor::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTrip_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_trip_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isDirection_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_direction_id_.value());
    }
    endBitPosition += 1;
    if (isStart_timeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_time_.value());
    }
    endBitPosition += 1;
    if (isStart_dateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_date_.value());
    }
    endBitPosition += 1;
    if (isSchedule_relationshipSet())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_schedule_relationship_.value());
    }

    return endBitPosition;
}

size_t TripDescriptor::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isTrip_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_trip_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isDirection_idSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), m_direction_id_.value());
    }
    endBitPosition += 1;
    if (isStart_timeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_time_.value());
    }
    endBitPosition += 1;
    if (isStart_dateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_start_date_.value());
    }
    endBitPosition += 1;
    if (isSchedule_relationshipSet())
    {
        endBitPosition = ::zserio::initializeOffsets(
                contextNode.getChildren().at(5), endBitPosition, m_schedule_relationship_.value());
    }

    return endBitPosition;
}

bool TripDescriptor::operator==(const TripDescriptor& other) const
{
    if (this != &other)
    {
        return
                ((!isTrip_idUsed()) ? !other.isTrip_idUsed() : (m_trip_id_ == other.m_trip_id_)) &&
                ((!isRoute_idUsed()) ? !other.isRoute_idUsed() : (m_route_id_ == other.m_route_id_)) &&
                ((!isDirection_idUsed()) ? !other.isDirection_idUsed() : (m_direction_id_ == other.m_direction_id_)) &&
                ((!isStart_timeUsed()) ? !other.isStart_timeUsed() : (m_start_time_ == other.m_start_time_)) &&
                ((!isStart_dateUsed()) ? !other.isStart_dateUsed() : (m_start_date_ == other.m_start_date_)) &&
                ((!isSchedule_relationshipUsed()) ? !other.isSchedule_relationshipUsed() : (m_schedule_relationship_ == other.m_schedule_relationship_));
    }

    return true;
}

uint32_t TripDescriptor::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isTrip_idUsed())
        result = ::zserio::calcHashCode(result, m_trip_id_);
    if (isRoute_idUsed())
        result = ::zserio::calcHashCode(result, m_route_id_);
    if (isDirection_idUsed())
        result = ::zserio::calcHashCode(result, m_direction_id_);
    if (isStart_timeUsed())
        result = ::zserio::calcHashCode(result, m_start_time_);
    if (isStart_dateUsed())
        result = ::zserio::calcHashCode(result, m_start_date_);
    if (isSchedule_relationshipUsed())
        result = ::zserio::calcHashCode(result, m_schedule_relationship_);

    return result;
}

void TripDescriptor::write(::zserio::BitStreamWriter& out) const
{
    if (isTrip_idSet())
    {
        out.writeBool(true);
        out.writeString(m_trip_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_idSet())
    {
        out.writeBool(true);
        out.writeString(m_route_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDirection_idSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_direction_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStart_timeSet())
    {
        out.writeBool(true);
        out.writeString(m_start_time_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStart_dateSet())
    {
        out.writeBool(true);
        out.writeString(m_start_date_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSchedule_relationshipSet())
    {
        out.writeBool(true);
        ::zserio::write(out, m_schedule_relationship_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void TripDescriptor::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isTrip_idSet())
    {
        out.writeBool(true);
        out.writeString(m_trip_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_idSet())
    {
        out.writeBool(true);
        out.writeString(m_route_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isDirection_idSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(2).getContext().write(
                ::zserio::VarIntNNArrayTraits<uint32_t>(), out, m_direction_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStart_timeSet())
    {
        out.writeBool(true);
        out.writeString(m_start_time_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isStart_dateSet())
    {
        out.writeBool(true);
        out.writeString(m_start_date_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSchedule_relationshipSet())
    {
        out.writeBool(true);
        ::zserio::write(contextNode.getChildren().at(5), out, m_schedule_relationship_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<::zserio::string<>> TripDescriptor::readTrip_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> TripDescriptor::readRoute_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> TripDescriptor::readDirection_id(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> TripDescriptor::readDirection_id(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(contextNode.getChildren().at(2).getContext().read(::zserio::VarIntNNArrayTraits<uint32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> TripDescriptor::readStart_time(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> TripDescriptor::readStart_date(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship> TripDescriptor::readSchedule_relationship(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship>(::zserio::read<::gtfsrealtime::ScheduleRelationship>(in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship> TripDescriptor::readSchedule_relationship(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship>(::zserio::read<::gtfsrealtime::ScheduleRelationship>(contextNode.getChildren().at(5), in));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::ScheduleRelationship>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/VehicleDescriptor.h>

namespace gtfsrealtime
{

VehicleDescriptor::VehicleDescriptor(const allocator_type&) noexcept :
        m_id_(::zserio::NullOpt),
        m_label_(::zserio::NullOpt),
        m_license_plate_(::zserio::NullOpt)
{
}

VehicleDescriptor::VehicleDescriptor(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_label_(readLabel(in, allocator)),
        m_license_plate_(readLicense_plate(in, allocator))
{
}

VehicleDescriptor::VehicleDescriptor(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator)),
        m_label_(readLabel(in, allocator)),
        m_license_plate_(readLicense_plate(in, allocator))
{
}

VehicleDescriptor::VehicleDescriptor(::zserio::PropagateAllocatorT,
        const VehicleDescriptor& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_label_(::zserio::allocatorPropagatingCopy(other.m_label_, allocator)),
        m_license_plate_(::zserio::allocatorPropagatingCopy(other.m_license_plate_, allocator))
{
}

::zserio::string<>& VehicleDescriptor::getId()
{
    return m_id_.value();
}

const ::zserio::string<>& VehicleDescriptor::getId() const
{
    return m_id_.value();
}

void VehicleDescriptor::setId(const ::zserio::string<>& id_)
{
    m_id_ = id_;
}

void VehicleDescriptor::setId(::zserio::string<>&& id_)
{
    m_id_ = ::std::move(id_);
}

bool VehicleDescriptor::isIdUsed() const
{
    return (isIdSet());
}

bool VehicleDescriptor::isIdSet() const
{
    return m_id_.hasValue();
}

void VehicleDescriptor::resetId()
{
    m_id_.reset();
}

::zserio::string<>& VehicleDescriptor::getLabel()
{
    return m_label_.value();
}

const ::zserio::string<>& VehicleDescriptor::getLabel() const
{
    return m_label_.value();
}

void VehicleDescriptor::setLabel(const ::zserio::string<>& label_)
{
    m_label_ = label_;
}

void VehicleDescriptor::setLabel(::zserio::string<>&& label_)
{
    m_label_ = ::std::move(label_);
}

bool VehicleDescriptor::isLabelUsed() const
{
    return (isLabelSet());
}

bool VehicleDescriptor::isLabelSet() const
{
    return m_label_.hasValue();
}

void VehicleDescriptor::resetLabel()
{
    m_label_.reset();
}

::zserio::string<>& VehicleDescriptor::getLicense_plate()
{
    return m_license_plate_.value();
}

const ::zserio::string<>& VehicleDescriptor::getLicense_plate() const
{
    return m_license_plate_.value();
}

void VehicleDescriptor::setLicense_plate(const ::zserio::string<>& license_plate_)
{
    m_license_plate_ = license_plate_;
}

void VehicleDescriptor::setLicense_plate(::zserio::string<>&& license_plate_)
{
    m_license_plate_ = ::std::move(license_plate_);
}

bool VehicleDescriptor::isLicense_plateUsed() const
{
    return (isLicense_plateSet());
}

bool VehicleDescriptor::isLicense_plateSet() const
{
    return m_license_plate_.hasValue();
}

void VehicleDescriptor::resetLicense_plate()
{
    m_license_plate_.reset();
}

void VehicleDescriptor::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild();
}

void VehicleDescriptor::initPackingContext(::zserio::PackingContextNode&) const
{
}

size_t VehicleDescriptor::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_id_.value());
    }
    endBitPosition += 1;
    if (isLabelSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_label_.value());
    }
    endBitPosition += 1;
    if (isLicense_plateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_license_plate_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehicleDescriptor::bitSizeOf(::zserio::PackingContextNode&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_id_.value());
    }
    endBitPosition += 1;
    if (isLabelSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_label_.value());
    }
    endBitPosition += 1;
    if (isLicense_plateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_license_plate_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehicleDescriptor::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_id_.value());
    }
    endBitPosition += 1;
    if (isLabelSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_label_.value());
    }
    endBitPosition += 1;
    if (isLicense_plateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_license_plate_.value());
    }

    return endBitPosition;
}

size_t VehicleDescriptor::initializeOffsets(::zserio::PackingContextNode&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isIdSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_id_.value());
    }
    endBitPosition += 1;
    if (isLabelSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_label_.value());
    }
    endBitPosition += 1;
    if (isLicense_plateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_license_plate_.value());
    }

    return endBitPosition;
}

bool VehicleDescriptor::operator==(const VehicleDescriptor& other) const
{
    if (this != &other)
    {
        return
                ((!isIdUsed()) ? !other.isIdUsed() : (m_id_ == other.m_id_)) &&
                ((!isLabelUsed()) ? !other.isLabelUsed() : (m_label_ == other.m_label_)) &&
                ((!isLicense_plateUsed()) ? !other.isLicense_plateUsed() : (m_license_plate_ == other.m_license_plate_));
    }

    return true;
}

uint32_t VehicleDescriptor::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isIdUsed())
        result = ::zserio::calcHashCode(result, m_id_);
    if (isLabelUsed())
        result = ::zserio::calcHashCode(result, m_label_);
    if (isLicense_plateUsed())
        result = ::zserio::calcHashCode(result, m_license_plate_);

    return result;
}

void VehicleDescriptor::write(::zserio::BitStreamWriter& out) const
{
    if (isIdSet())
    {
        out.writeBool(true);
        out.writeString(m_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isLabelSet())
    {
        out.writeBool(true);
        out.writeString(m_label_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isLicense_plateSet())
    {
        out.writeBool(true);
        out.writeString(m_license_plate_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void VehicleDescriptor::write(::zserio::PackingContextNode&, ::zserio::BitStreamWriter& out) const
{
    if (isIdSet())
    {
        out.writeBool(true);
        out.writeString(m_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isLabelSet())
    {
        out.writeBool(true);
        out.writeString(m_label_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isLicense_plateSet())
    {
        out.writeBool(true);
        out.writeString(m_license_plate_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<::zserio::string<>> VehicleDescriptor::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> VehicleDescriptor::readLabel(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> VehicleDescriptor::readLicense_plate(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/EntitySelector.h>

namespace gtfsrealtime
{

EntitySelector::EntitySelector(const allocator_type&) noexcept :
        m_agency_id_(::zserio::NullOpt),
        m_route_id_(::zserio::NullOpt),
        m_route_type_(::zserio::NullOpt),
        m_trip_(::zserio::NullOpt),
        m_stop_id_(::zserio::NullOpt)
{
}

EntitySelector::EntitySelector(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_agency_id_(readAgency_id(in, allocator)),
        m_route_id_(readRoute_id(in, allocator)),
        m_route_type_(readRoute_type(in)),
        m_trip_(readTrip(in, allocator)),
        m_stop_id_(readStop_id(in, allocator))
{
}

EntitySelector::EntitySelector(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_agency_id_(readAgency_id(in, allocator)),
        m_route_id_(readRoute_id(in, allocator)),
        m_route_type_(readRoute_type(contextNode, in)),
        m_trip_(readTrip(contextNode, in, allocator)),
        m_stop_id_(readStop_id(in, allocator))
{
}

EntitySelector::EntitySelector(::zserio::PropagateAllocatorT,
        const EntitySelector& other, const allocator_type& allocator) :
        m_agency_id_(::zserio::allocatorPropagatingCopy(other.m_agency_id_, allocator)),
        m_route_id_(::zserio::allocatorPropagatingCopy(other.m_route_id_, allocator)),
        m_route_type_(::zserio::allocatorPropagatingCopy(other.m_route_type_, allocator)),
        m_trip_(::zserio::allocatorPropagatingCopy(other.m_trip_, allocator)),
        m_stop_id_(::zserio::allocatorPropagatingCopy(other.m_stop_id_, allocator))
{
}

::zserio::string<>& EntitySelector::getAgency_id()
{
    return m_agency_id_.value();
}

const ::zserio::string<>& EntitySelector::getAgency_id() const
{
    return m_agency_id_.value();
}

void EntitySelector::setAgency_id(const ::zserio::string<>& agency_id_)
{
    m_agency_id_ = agency_id_;
}

void EntitySelector::setAgency_id(::zserio::string<>&& agency_id_)
{
    m_agency_id_ = ::std::move(agency_id_);
}

bool EntitySelector::isAgency_idUsed() const
{
    return (isAgency_idSet());
}

bool EntitySelector::isAgency_idSet() const
{
    return m_agency_id_.hasValue();
}

void EntitySelector::resetAgency_id()
{
    m_agency_id_.reset();
}

::zserio::string<>& EntitySelector::getRoute_id()
{
    return m_route_id_.value();
}

const ::zserio::string<>& EntitySelector::getRoute_id() const
{
    return m_route_id_.value();
}

void EntitySelector::setRoute_id(const ::zserio::string<>& route_id_)
{
    m_route_id_ = route_id_;
}

void EntitySelector::setRoute_id(::zserio::string<>&& route_id_)
{
    m_route_id_ = ::std::move(route_id_);
}

bool EntitySelector::isRoute_idUsed() const
{
    return (isRoute_idSet());
}

bool EntitySelector::isRoute_idSet() const
{
    return m_route_id_.hasValue();
}

void EntitySelector::resetRoute_id()
{
    m_route_id_.reset();
}

int32_t EntitySelector::getRoute_type() const
{
    return m_route_type_.value();
}

void EntitySelector::setRoute_type(int32_t route_type_)
{
    m_route_type_ = route_type_;
}

bool EntitySelector::isRoute_typeUsed() const
{
    return (isRoute_typeSet());
}

bool EntitySelector::isRoute_typeSet() const
{
    return m_route_type_.hasValue();
}

void EntitySelector::resetRoute_type()
{
    m_route_type_.reset();
}

::gtfsrealtime::TripDescriptor& EntitySelector::getTrip()
{
    return m_trip_.value();
}

const ::gtfsrealtime::TripDescriptor& EntitySelector::getTrip() const
{
    return m_trip_.value();
}

void EntitySelector::setTrip(const ::gtfsrealtime::TripDescriptor& trip_)
{
    m_trip_ = trip_;
}

void EntitySelector::setTrip(::gtfsrealtime::TripDescriptor&& trip_)
{
    m_trip_ = ::std::move(trip_);
}

bool EntitySelector::isTripUsed() const
{
    return (isTripSet());
}

bool EntitySelector::isTripSet() const
{
    return m_trip_.hasValue();
}

void EntitySelector::resetTrip()
{
    m_trip_.reset();
}

::zserio::string<>& EntitySelector::getStop_id()
{
    return m_stop_id_.value();
}

const ::zserio::string<>& EntitySelector::getStop_id() const
{
    return m_stop_id_.value();
}

void EntitySelector::setStop_id(const ::zserio::string<>& stop_id_)
{
    m_stop_id_ = stop_id_;
}

void EntitySelector::setStop_id(::zserio::string<>&& stop_id_)
{
    m_stop_id_ = ::std::move(stop_id_);
}

bool EntitySelector::isStop_idUsed() const
{
    return (isStop_idSet());
}

bool EntitySelector::isStop_idSet() const
{
    return m_stop_id_.hasValue();
}

void EntitySelector::resetStop_id()
{
    m_stop_id_.reset();
}

void EntitySelector::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
    contextNode.createChild().createContext();
    ::gtfsrealtime::TripDescriptor::createPackingContext(contextNode.createChild());
    contextNode.createChild();
}

void EntitySelector::initPackingContext(::zserio::PackingContextNode& contextNode) const
{
    if (isRoute_typeSet())
    {
        contextNode.getChildren().at(2).getContext().init(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_route_type_.value());
    }
    if (isTripSet())
    {
        m_trip_.value().initPackingContext(contextNode.getChildren().at(3));
    }
}

size_t EntitySelector::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAgency_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_agency_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_typeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_route_type_.value());
    }
    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition += m_trip_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }

    return endBitPosition - bitPosition;
}

size_t EntitySelector::bitSizeOf(::zserio::PackingContextNode& contextNode, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAgency_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_agency_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_typeSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_route_type_.value());
    }
    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition += m_trip_.value().bitSizeOf(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }

    return endBitPosition - bitPosition;
}

size_t EntitySelector::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAgency_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_agency_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_typeSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_route_type_.value());
    }
    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition = m_trip_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }

    return endBitPosition;
}

size_t EntitySelector::initializeOffsets(::zserio::PackingContextNode& contextNode, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isAgency_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_agency_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_route_id_.value());
    }
    endBitPosition += 1;
    if (isRoute_typeSet())
    {
        endBitPosition += contextNode.getChildren().at(2).getContext().bitSizeOf(
                ::zserio::VarIntNNArrayTraits<int32_t>(), m_route_type_.value());
    }
    endBitPosition += 1;
    if (isTripSet())
    {
        endBitPosition = m_trip_.value().initializeOffsets(
                contextNode.getChildren().at(3), endBitPosition);
    }
    endBitPosition += 1;
    if (isStop_idSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_stop_id_.value());
    }

    return endBitPosition;
}

bool EntitySelector::operator==(const EntitySelector& other) const
{
    if (this != &other)
    {
        return
                ((!isAgency_idUsed()) ? !other.isAgency_idUsed() : (m_agency_id_ == other.m_agency_id_)) &&
                ((!isRoute_idUsed()) ? !other.isRoute_idUsed() : (m_route_id_ == other.m_route_id_)) &&
                ((!isRoute_typeUsed()) ? !other.isRoute_typeUsed() : (m_route_type_ == other.m_route_type_)) &&
                ((!isTripUsed()) ? !other.isTripUsed() : (m_trip_ == other.m_trip_)) &&
                ((!isStop_idUsed()) ? !other.isStop_idUsed() : (m_stop_id_ == other.m_stop_id_));
    }

    return true;
}

uint32_t EntitySelector::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isAgency_idUsed())
        result = ::zserio::calcHashCode(result, m_agency_id_);
    if (isRoute_idUsed())
        result = ::zserio::calcHashCode(result, m_route_id_);
    if (isRoute_typeUsed())
        result = ::zserio::calcHashCode(result, m_route_type_);
    if (isTripUsed())
        result = ::zserio::calcHashCode(result, m_trip_);
    if (isStop_idUsed())
        result = ::zserio::calcHashCode(result, m_stop_id_);

    return result;
}

void EntitySelector::write(::zserio::BitStreamWriter& out) const
{
    if (isAgency_idSet())
    {
        out.writeBool(true);
        out.writeString(m_agency_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_idSet())
    {
        out.writeBool(true);
        out.writeString(m_route_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_typeSet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_route_type_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isTripSet())
    {
        out.writeBool(true);
        m_trip_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void EntitySelector::write(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamWriter& out) const
{
    if (isAgency_idSet())
    {
        out.writeBool(true);
        out.writeString(m_agency_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_idSet())
    {
        out.writeBool(true);
        out.writeString(m_route_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRoute_typeSet())
    {
        out.writeBool(true);
        contextNode.getChildren().at(2).getContext().write(
                ::zserio::VarIntNNArrayTraits<int32_t>(), out, m_route_type_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isTripSet())
    {
        out.writeBool(true);
        m_trip_.value().write(contextNode.getChildren().at(3), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isStop_idSet())
    {
        out.writeBool(true);
        out.writeString(m_stop_id_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<::zserio::string<>> EntitySelector::readAgency_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> EntitySelector::readRoute_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> EntitySelector::readRoute_type(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(static_cast<int32_t>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int32_t> EntitySelector::readRoute_type(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int32_t>(contextNode.getChildren().at(2).getContext().read(::zserio::VarIntNNArrayTraits<int32_t>(), in));
    }

    return ::zserio::InplaceOptionalHolder<int32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor> EntitySelector::readTrip(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::gtfsrealtime::TripDescriptor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor> EntitySelector::readTrip(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::gtfsrealtime::TripDescriptor(contextNode.getChildren().at(3), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::gtfsrealtime::TripDescriptor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::zserio::string<>> EntitySelector::readStop_id(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <functional>

#include <gtfsrealtime/TranslatedString.h>

namespace gtfsrealtime
{

TranslatedString::ZserioElementFactory_translation::ZserioElementFactory_translation(TranslatedString& owner) :
        m_ownerRef(owner)
{}

void TranslatedString::ZserioElementFactory_translation::create(::zserio::vector<::gtfsrealtime::Translation>& array,
        ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(in, array.get_allocator());
}

void TranslatedString::ZserioElementFactory_translation::create(::zserio::PackingContextNode& contextNode,
        ::zserio::vector<::gtfsrealtime::Translation>& array, ::zserio::BitStreamReader& in, size_t index) const
{
    (void)index;
    array.emplace_back(contextNode, in, array.get_allocator());
}

TranslatedString::TranslatedString(const allocator_type& allocator) noexcept :
        m_translation_(::zserio::ObjectArrayTraits<::gtfsrealtime::Translation, ZserioElementFactory_translation>(), allocator)
{
}

TranslatedString::TranslatedString(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_translation_(readTranslation(in, allocator))
{
}

TranslatedString::TranslatedString(::zserio::PackingContextNode& contextNode, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_translation_(readTranslation(contextNode, in, allocator))
{
}

TranslatedString::TranslatedString(::zserio::PropagateAllocatorT,
        const TranslatedString& other, const allocator_type& allocator) :
        m_translation_(::zserio::allocatorPropagatingCopy(other.m_translation_, allocator))
{
}

::zserio::vector<::gtfsrealtime::Translation>& TranslatedString::getTranslation()
{
    return m_translation_.getRawArray();
}

const ::zserio::vector<::gtfsrealtime::Translation>& TranslatedString::getTranslation() const
{
    return m_translation_.getRawArray();
}

void TranslatedString::setTranslation(const ::zserio::vector<::gtfsrealtime::Translation>& translation_)
{
    m_translation_ = ZserioArrayType_translation(translation_, ::zserio::ObjectArrayTraits<::gtfsrealtime::Translation, ZserioElementFactory_translation>());
}

void TranslatedString::setTranslation(::zserio::vector<::gtfsrealtime::Translation>&& translation_)
{
    m_translation_ = ZserioArrayType_translation(std::move(translation_), ::zserio::ObjectArrayTraits<::gtfsrealtime::Translation, ZserioElementFactory_translation>());
}

void TranslatedString::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
}

void TranslatedString::initPackingContext(::zserio::PackingContextNode&) const
{
}

size_t TranslatedString::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_translation_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TranslatedString::bitSizeOf(::zserio::PackingContextNode&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_translation_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TranslatedString::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_translation_.initializeOffsets(
            endBitPosition);

    return endBitPosition;
}

size_t TranslatedString::initializeOffsets(::zserio::PackingContextNode&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_translation_.initializeOffsetsPacked(
            endBitPosition);

    return endBitPosition;
}

bool TranslatedString::operator==(const TranslatedString& other) const
{
    if (this != &other)
    {
        return
                (m_translation_ == other.m_translation_);
    }

    return true;
}

uint32_t TranslatedString::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_translation_);

    return result;
}

void TranslatedString::write(::zserio::BitStreamWriter& out) const
{
    m_translation_.write(out);
}

void TranslatedString::write(::zserio::PackingContextNode&, ::zserio::BitStreamWriter& out) const
{
    m_translation_.writePacked(out);
}

TranslatedString::ZserioArrayType_translation TranslatedString::readTranslation(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_translation readField(::zserio::ObjectArrayTraits<::gtfsrealtime::Translation, ZserioElementFactory_translation>(), allocator);
    readField.read(in, ZserioElementFactory_translation(*this));

    return readField;
}

TranslatedString::ZserioArrayType_translation TranslatedString::readTranslation(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_translation readField(::zserio::ObjectArrayTraits<::gtfsrealtime::Translation, ZserioElementFactory_translation>(), allocator);
    readField.readPacked(in, ZserioElementFactory_translation(*this));

    return readField;
}

} // namespace gtfsrealtime

/**
 * Automatically generated by Zserio C++ extension version 2.9.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <gtfsrealtime/Translation.h>

namespace gtfsrealtime
{

Translation::Translation(const allocator_type& allocator) noexcept :
        m_text_(allocator),
        m_language_(::zserio::NullOpt)
{
}

Translation::Translation(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_text_(readText(in, allocator)),
        m_language_(readLanguage(in, allocator))
{
}

Translation::Translation(::zserio::PackingContextNode&, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_text_(readText(in, allocator)),
        m_language_(readLanguage(in, allocator))
{
}

Translation::Translation(::zserio::PropagateAllocatorT,
        const Translation& other, const allocator_type& allocator) :
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator)),
        m_language_(::zserio::allocatorPropagatingCopy(other.m_language_, allocator))
{
}

::zserio::string<>& Translation::getText()
{
    return m_text_;
}

const ::zserio::string<>& Translation::getText() const
{
    return m_text_;
}

void Translation::setText(const ::zserio::string<>& text_)
{
    m_text_ = text_;
}

void Translation::setText(::zserio::string<>&& text_)
{
    m_text_ = ::std::move(text_);
}

::zserio::string<>& Translation::getLanguage()
{
    return m_language_.value();
}

const ::zserio::string<>& Translation::getLanguage() const
{
    return m_language_.value();
}

void Translation::setLanguage(const ::zserio::string<>& language_)
{
    m_language_ = language_;
}

void Translation::setLanguage(::zserio::string<>&& language_)
{
    m_language_ = ::std::move(language_);
}

bool Translation::isLanguageUsed() const
{
    return (isLanguageSet());
}

bool Translation::isLanguageSet() const
{
    return m_language_.hasValue();
}

void Translation::resetLanguage()
{
    m_language_.reset();
}

void Translation::createPackingContext(::zserio::PackingContextNode& contextNode)
{
    contextNode.createChild();
    contextNode.createChild();
}

void Translation::initPackingContext(::zserio::PackingContextNode&) const
{
}

size_t Translation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += 1;
    if (isLanguageSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_language_.value());
    }

    return endBitPosition - bitPosition;
}

size_t Translation::bitSizeOf(::zserio::PackingContextNode&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += 1;
    if (isLanguageSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_language_.value());
    }

    return endBitPosition - bitPosition;
}

size_t Translation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += 1;
    if (isLanguageSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_language_.value());
    }

    return endBitPosition;
}

size_t Translation::initializeOffsets(::zserio::PackingContextNode&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_text_);
    endBitPosition += 1;
    if (isLanguageSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_language_.value());
    }

    return endBitPosition;
}

bool Translation::operator==(const Translation& other) const
{
    if (this != &other)
    {
        return
                (m_text_ == other.m_text_) &&
                ((!isLanguageUsed()) ? !other.isLanguageUsed() : (m_language_ == other.m_language_));
    }

    return true;
}

uint32_t Translation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_text_);
    if (isLanguageUsed())
        result = ::zserio::calcHashCode(result, m_language_);

    return result;
}

void Translation::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_text_);
    if (isLanguageSet())
    {
        out.writeBool(true);
        out.writeString(m_language_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void Translation::write(::zserio::PackingContextNode&, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_text_);
    if (isLanguageSet())
    {
        out.writeBool(true);
        out.writeString(m_language_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::string<> Translation::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

::zserio::InplaceOptionalHolder<::zserio::string<>> Translation::readLanguage(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace gtfsrealtime
